[
  {
    "id": 1,
    "name": "Terminal To-Do List App",
    "challenge": 1,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Build a command-line app where users can add, remove, complete, and list to-do items. Use slices, structs, maps, and interfaces for task logic. Handle invalid input gracefully. Demonstrate use of `defer`, `panic/recover`, and `generics` for typed lists. Include usage of packages, visibility rules, and time scheduling.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 2,
    "name": "Fraction Calculator CLI",
    "challenge": 2,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Create a CLI app that performs arithmetic operations on fractions. The user inputs two fractions and the operator (+, -, *, /). Use structs to represent fractions, implement arithmetic methods, and include iota-based enums for operations. Use generics to handle common math utility functions. Handle invalid input with proper error handling and show clear output. Log parsing and computation time.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 3,
    "name": "Personal Budget Tracker",
    "challenge": 3,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Build a terminal-based app to track income and expenses across categories. The user can add entries (amount, label, type), delete them, and view summaries by date or category. Use maps for storage, slices for history, structs for entries, and interfaces for printing/export logic. Implement custom error handling, use `defer` for file saves, and allow scheduling monthly report generation. Use iota to define transaction types and make the app modular via packages. Add type aliases and embedded types for clean models.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 4,
    "name": "ASCII Drawing Canvas",
    "challenge": 4,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Design a terminal canvas where users can draw lines, rectangles, and fill areas using ASCII symbols. The canvas is a 2D slice of runes. Use structs for shapes, methods to render them, and pointers to modify canvas in place. Allow drawing via CLI commands. Use interfaces for rendering to terminal or file. Handle parsing errors, display drawing time, and build reusable geometry packages with full godoc comments. Use iota for shape types and create a generic layer for draw algorithms.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 5,
    "name": "Markdown to Terminal Renderer",
    "challenge": 5,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Create a parser that reads `.md` files and renders them into styled terminal output (bold, italics, headers). Use slices for lines, maps for tag detection, structs for tokens, and interfaces to allow different rendering styles. Handle syntax errors with custom types, and log render duration. Use embedded types for token models and godoc-style comments. Employ `iota` for token types, generics for walking AST nodes, and schedule auto-refresh from file every minute.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 6,
    "name": "JSON Validator & Formatter",
    "challenge": 6,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Develop a CLI tool that reads a JSON string or file and validates its syntax. If valid, it outputs the formatted JSON (pretty print). Use structs and maps for unmarshaling data, type definitions for token types, and interfaces to abstract input sources. Errors must be reported with custom types, and the parsing process timed and logged. Apply generics for recursive structure traversal and defer file closing properly.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 7,
    "name": "Command-Line Flashcard App",
    "challenge": 7,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Create an interactive terminal app to study flashcards. Cards can be added, removed, and practiced. Users can shuffle cards and track correct/incorrect answers. Use slices for card storage, maps for category filtering, structs for card models, and pointer receivers for mutation. Handle IO via interfaces, use iota for difficulty levels, and allow scheduled study sessions via timers. Wrap errors with custom messages and document your code with godoc.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 8,
    "name": "Simple Terminal Blog Engine",
    "challenge": 8,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Design a markdown-based blog system in the terminal. The user can write, list, preview, and delete posts stored in files. Use structs for post metadata, maps for caching, interfaces for rendering, and slices for sorting. Use `iota` for post states, generics for utilities (like sorting/filtering), and godoc for self-documented commands. Track editing time and log errors gracefully.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 9,
    "name": "Contact Book App (Terminal Edition)",
    "challenge": 9,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Build a contact management app where users can add, delete, and search contacts. Each contact contains a name, phone, email, and optional note. Use slices and maps to manage data, structs for contact models, and pointers for edits. Implement deferred save, custom errors for duplicates, generics for validation utilities, and display contacts nicely formatted using packages. Use `iota` to define contact statuses and log operations with timestamps.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 10,
    "name": "Quiz Generator from File",
    "challenge": 10,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Write a CLI app that reads quiz questions from a text or CSV file, presents them one-by-one, tracks score, and prints a final result. Use structs for questions, maps for answer tracking, slices for question pools, and interfaces for file input. Leverage generics to handle flexible scoring rules, use godoc for all public methods, and panic-recover to handle unexpected file formats. Include iota-based constants for difficulty and schedule quiz start with a countdown timer.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 11,
    "name": "CSV Report Analyzer",
    "challenge": 11,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Create a terminal program that reads CSV files and generates summaries: column averages, counts, and min/max values. Use structs for rows, maps for aggregates, and slices for storing lines. Use functions with named returns, generic utilities for math operations, error handling for invalid rows, and godoc for documenting each component. Use `iota` for output format options (text, JSON), and channels to simulate async file loading. Include time tracking and file import via packages.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 12,
    "name": "Go Notes Organizer",
    "challenge": 12,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Build a personal note organizer with tagging, archiving, and category filtering. Store notes in-memory using slices and maps, and persist to a JSON file. Use embedded types to define note metadata, iota enums for status, and interfaces to abstract storage. Include detailed godoc, panic-safe file writes, time scheduling for auto-backup, and scan input mode for multiline entry. Generics can help with note filtering and sorting operations.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 13,
    "name": "Terminal Music Playlist Manager",
    "challenge": 13,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Build a CLI app to manage playlists and tracks: add, delete, reorder, shuffle. Store playlists as slices of structs, and use maps to quickly look up by genre. Implement generic sorting and embedded metadata for tracks. Use iota to represent playback modes. Schedule playback simulation with timers. Handle errors with custom messages and use defer to simulate saving before exit.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 14,
    "name": "Basic Email Composer",
    "challenge": 14,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Create a tool that composes email drafts in plain text format, allowing subject, recipient, body, and attachments (simulated). Use structs for message parts, slices for multiple recipients, and maps for configuration. Use interfaces for different output formats. Apply iota for email priorities. Validate user input and simulate send queue with time scheduling. Use `defer` to simulate cleaning up files, and `panic/recover` to handle corrupted inputs.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 15,
    "name": "Unit Converter Terminal Tool",
    "challenge": 15,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Create a terminal-based unit converter (e.g. km → mi, kg → lb). Users choose unit category and input a value. Use maps for conversion tables, structs for input/output, and interfaces for mode rendering (verbose/compact). Use type aliasing for units, defer for exit confirmation, and panic-recover for invalid categories. Implement godoc documentation and generic math conversion handlers. Include a scheduler to reset stats every 10 minutes.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 16,
    "name": "Command-Line Book Library",
    "challenge": 16,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Design a CLI app that manages a personal book library. Users can add, list, delete, and search for books. Each book includes title, author, year, tags, and status (read/unread). Use structs and embedded types for models, slices and maps for storage, and interfaces for search strategies. Implement iota enums for status, use `defer` to simulate auto-saving, and create generic sort/filter functions. Use `time` to track reading sessions and `panic/recover` to handle corrupted data entries.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 17,
    "name": "Terminal Habit Tracker",
    "challenge": 17,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Build a terminal app that allows users to track daily habits and visualize streaks. Use slices and structs to store daily logs, and maps for fast habit lookup. Provide CLI commands to mark habits as done, reset streaks, and see calendar views. Use generics for utilities, defer for session save, time package for daily logic, iota for habit type constants, and interfaces for reporting. Errors must be custom handled and the app fully documented.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 18,
    "name": "CLI Portfolio Tracker",
    "challenge": 18,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Track a simulated investment portfolio via the terminal. Users can add assets (stocks, crypto), update prices, and compute gains/losses. Use structs with embedded types, slices and maps for holding entries, and interfaces for export and analytics. Use `iota` for asset types, `defer` for file save, `generics` for computing stats, and `channels` for simulated price feeds. Add full godoc, visibility encapsulation, and timed refresh every minute.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 19,
    "name": "CLI Restaurant Order System",
    "challenge": 19,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Simulate a simple restaurant order system where the user can add items to an order, print the bill, and apply promotions. Use structs and slices for order lines, maps for price lists, and interfaces for payment methods. Use `iota` to define menu categories. Generics can help with totals and filtering. Schedule auto-reset of session every hour and gracefully handle invalid menu input. Defer order archiving and include rich godoc documentation.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 20,
    "name": "Simple Calendar CLI App",
    "challenge": 20,
    "level": 1,
    "completed": false,
    "published": false,
    "description": "Design a terminal calendar that lets users add events with title, time, and duration. Use structs for events, slices for storage, maps for fast date lookup, and interfaces for exporting to text/JSON. Implement `iota` for event types, generics for sorting by time, and time package for scheduling reminders. Add full godoc documentation, and handle error cases with recovery and formatting. Use visibility rules and defer for cleanup tasks.",
    "tags": [
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Channels Basics",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 21,
    "name": "Concurrent Web Scraper with Worker Pool",
    "challenge": 1,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Create a command-line web scraper that takes a list of URLs and extracts titles from each page concurrently using a worker pool. Control concurrency with buffered channels and semaphores. Use context for timeout and cancellation, and implement graceful shutdown. Aggregate results via fan-in and publish with goroutines. Add retry logic with exponential backoff and channel direction constraints. All errors must be handled or wrapped. Benchmark the performance using `testing`, and guard against goroutine leaks. Include coverage and mocking for request logic.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Slices",
      "Maps",
      "Structs",
      "Functions",
      "Pointers",
      "Interfaces",
      "Error Handling",
      "Generics",
      "Defer",
      "Make-New",
      "Packages",
      "Imports",
      "Visibility",
      "Print-Scan",
      "Godoc",
      "Go Tools"
    ]
  },
  {
    "id": 22,
    "name": "Concurrent File Hashing CLI Tool",
    "challenge": 2,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Build a CLI tool that scans a folder recursively, hashes each file (e.g., SHA256), and outputs the result. Use a worker pool to hash files concurrently, ensure thread safety with mutex or channel-based coordination. Use WaitGroups for lifecycle, context for cancellation, and channels for piping results. Report memory usage and detect deadlocks. Use go test + benchmarking for file size impact and profile goroutine counts. Tag all errors, and use channel direction for clean API design. Debounce duplicate file events.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Constants",
      "Basic Types",
      "Functions",
      "Error Handling",
      "Structs",
      "Pointers",
      "Slices",
      "Maps",
      "Print-Scan",
      "Interfaces",
      "Defer",
      "Make-New",
      "Packages",
      "Imports",
      "Godoc",
      "Go Tools"
    ]
  },
  {
    "id": 23,
    "name": "Concurrent Sitemap Generator",
    "challenge": 3,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Write a tool that crawls a website (starting from a URL) and generates a sitemap.xml. Crawl pages concurrently with a worker pool. Use context for max-depth timeout. Coordinate crawling with fan-out/fan-in channels. Use maps for visited links, mutex to guard shared state, and semaphores to limit parallel requests. Track failures with custom errors. Use go test and benchmarks to test large sites and memory consumption.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Constants",
      "Shadowing",
      "Basic Types",
      "Operators",
      "If-For-Switch-Select",
      "For-Range",
      "Blank Identifier",
      "Functions",
      "Named Returns",
      "Zero Values",
      "Slices",
      "Arrays",
      "Maps",
      "Structs",
      "Method Receivers",
      "Pointers",
      "Type Alias",
      "Type Definition",
      "Type Embedding",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Panic-Recover",
      "Defer",
      "Iota-Enums",
      "Godoc",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 24,
    "name": "Live File Monitor with Debouncing",
    "challenge": 4,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Watch a folder and detect changes (add, delete, modify). Trigger a rebuild or processing function, but debounce rapid changes using channels and timers. Use goroutines to isolate watch logic, select for timeout, and buffered channels for queuing events. Gracefully shut down watchers with context. Use interfaces for file systems to mock in tests. Show goroutine leak avoidance and use profiling to measure performance.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Constants",
      "Basic Types",
      "Functions",
      "Error Handling",
      "Structs",
      "Pointers",
      "Interfaces",
      "Generics",
      "Defer",
      "Make-New",
      "Packages",
      "Imports",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 25,
    "name": "Realtime Terminal Chat Between Tabs (Local)",
    "challenge": 5,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Create a realtime chat that runs locally in multiple terminal tabs using a shared file or socket. Each tab listens for new messages via goroutines and broadcasts them with fan-out pattern. Use channels to debounce user input. Implement graceful exit with signal handling and context. Use select to multiplex input/output channels. Test concurrency correctness, race conditions, and memory profiling. Include table-driven tests and full godoc.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Constants",
      "Basic Types",
      "Operators",
      "Functions",
      "Slices",
      "Structs",
      "Pointers",
      "Interfaces",
      "Error Handling",
      "Defer",
      "Packages",
      "Imports",
      "Visibility",
      "Make-New",
      "Print-Scan",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 26,
    "name": "Concurrent Image Processor CLI",
    "challenge": 6,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Create a tool that processes multiple images (resize, crop, compress) concurrently. Read images from a folder, process each one in a goroutine using a worker pool and buffered channels. Use semaphores to control concurrency, context for timeout, and graceful shutdown. Track processing time and memory usage. Include panic-safe processing, custom errors, and retry logic. Use fan-out to push work and fan-in to collect results. Profile the number of goroutines and file I/O time.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Constants",
      "Basic Types",
      "Functions",
      "Pointers",
      "Error Handling",
      "Slices",
      "Maps",
      "Structs",
      "Interfaces",
      "Generics",
      "Defer",
      "Make-New",
      "Packages",
      "Imports",
      "Print-Scan",
      "Godoc",
      "Go Tools",
      "Time-Scheduling"
    ]
  },
  {
    "id": 27,
    "name": "Parallel Text Search Engine",
    "challenge": 7,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Build a simple search engine that scans `.txt` files in a folder and returns matches for a keyword. Each file is read concurrently and parsed using a pipeline of goroutines. Fan-out distributes the work; fan-in collects the results. Limit concurrency with semaphores. Use context for timeout, debounce repeated triggers, and guard against race conditions with safe concurrent maps. Add full tests and benchmarking to evaluate file count scaling.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Basic Types",
      "Functions",
      "Structs",
      "Slices",
      "Maps",
      "Interfaces",
      "Pointers",
      "Error Handling",
      "Generics",
      "Make-New",
      "Defer",
      "Godoc",
      "Packages",
      "Imports",
      "Print-Scan",
      "Visibility",
      "Go Tools",
      "Time-Scheduling"
    ]
  },
  {
    "id": 28,
    "name": "Parallel Markdown to HTML Converter",
    "challenge": 8,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Convert multiple markdown `.md` files into HTML files concurrently. Use a worker pool to manage file conversion, context for timeout, and select for tracking output status. Use channels to push converted HTML into a write queue. Add graceful shutdown, mockable I/O interface, and retry logic for failed writes. Track performance with profiling and tests. Avoid goroutine leaks and detect closed channels properly.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Constants",
      "Structs",
      "Functions",
      "Pointers",
      "Slices",
      "Maps",
      "Interfaces",
      "Error Handling",
      "Generics",
      "Make-New",
      "Defer",
      "Packages",
      "Imports",
      "Godoc",
      "Print-Scan",
      "Visibility",
      "Go Tools",
      "Time-Scheduling"
    ]
  },
  {
    "id": 29,
    "name": "Live Stock Price Ticker Simulator",
    "challenge": 9,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Simulate real-time stock price feeds and visualize the stream in the terminal. Use goroutines for each feed, buffered channels to deliver prices, fan-out for multiple consumers, and select to handle ticks. Use `Ticker` and `Timer` to manage update intervals. Implement graceful shutdown, context-based control, and semaphore-based throttling. Debounce large bursts of price updates. Profile performance and detect leaks on exit.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Basic Types",
      "Slices",
      "Maps",
      "Functions",
      "Structs",
      "Interfaces",
      "Pointers",
      "Error Handling",
      "Generics",
      "Defer",
      "Make-New",
      "Packages",
      "Imports",
      "Print-Scan",
      "Go Tools",
      "Godoc",
      "Time-Scheduling"
    ]
  },
  {
    "id": 29,
    "name": "Live Stock Price Ticker Simulator",
    "challenge": 9,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Simulate real-time stock price feeds and visualize the stream in the terminal. Use goroutines for each feed, buffered channels to deliver prices, fan-out for multiple consumers, and select to handle ticks. Use `Ticker` and `Timer` to manage update intervals. Implement graceful shutdown, context-based control, and semaphore-based throttling. Debounce large bursts of price updates. Profile performance and detect leaks on exit.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Basic Types",
      "Slices",
      "Maps",
      "Functions",
      "Structs",
      "Interfaces",
      "Pointers",
      "Error Handling",
      "Generics",
      "Defer",
      "Make-New",
      "Packages",
      "Imports",
      "Print-Scan",
      "Go Tools",
      "Godoc",
      "Time-Scheduling"
    ]
  },
  {
    "id": 31,
    "name": "Concurrent Email Sender Simulator",
    "challenge": 11,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Simulate sending hundreds of emails concurrently. Each email task includes recipient, subject, and delay. Use a buffered job queue, fan-out workers, and semaphores to throttle concurrency. Track delivery stats with fan-in, and allow graceful cancelation via context. Apply backoff strategy on failure, use safe concurrent maps for stats, and mock SMTP with interfaces. Profile memory use and test for channel leaks.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Functions",
      "Slices",
      "Maps",
      "Structs",
      "Interfaces",
      "Error Handling",
      "Generics",
      "Pointers",
      "Defer",
      "Make-New",
      "Packages",
      "Imports",
      "Godoc",
      "Print-Scan",
      "Visibility",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 31,
    "name": "Concurrent Email Sender Simulator",
    "challenge": 11,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Simulate sending hundreds of emails concurrently. Each email task includes recipient, subject, and delay. Use a buffered job queue, fan-out workers, and semaphores to throttle concurrency. Track delivery stats with fan-in, and allow graceful cancelation via context. Apply backoff strategy on failure, use safe concurrent maps for stats, and mock SMTP with interfaces. Profile memory use and test for channel leaks.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Functions",
      "Slices",
      "Maps",
      "Structs",
      "Interfaces",
      "Error Handling",
      "Generics",
      "Pointers",
      "Defer",
      "Make-New",
      "Packages",
      "Imports",
      "Godoc",
      "Print-Scan",
      "Visibility",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 33,
    "name": "Real-Time Log Aggregator",
    "challenge": 13,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Design a log processor that reads from multiple log files concurrently and streams their data into a central pipeline. Use goroutines to tail each file, channels to push logs, and fan-in to aggregate output. Use select with context and ticker for timeout and heartbeat. Avoid leaks by monitoring goroutine count. Create benchmarks and run profiling to optimize channel buffer sizes. Support graceful shutdown and restart.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Functions",
      "Structs",
      "Slices",
      "Pointers",
      "Maps",
      "Error Handling",
      "Generics",
      "Interfaces",
      "Defer",
      "Packages",
      "Imports",
      "Print-Scan",
      "Godoc",
      "Visibility",
      "Time-Scheduling",
      "Go Tools"
    ]
  },
  {
    "id": 34,
    "name": "Concurrent PDF Combiner",
    "challenge": 14,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Merge multiple PDFs into a single document using concurrent goroutines. Each file is validated and parsed concurrently. Use semaphores to control concurrency, fan-out to distribute the reading, and fan-in to push into the final writer. Use context to abort on timeout, benchmark memory use, and ensure channel closing correctness. Provide retry logic on file read error. Test with mock readers.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Functions",
      "Slices",
      "Structs",
      "Interfaces",
      "Pointers",
      "Error Handling",
      "Generics",
      "Defer",
      "Packages",
      "Imports",
      "Godoc",
      "Visibility",
      "Go Tools"
    ]
  },
  {
    "id": 35,
    "name": "Live Progress Monitor for Tasks",
    "challenge": 15,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Simulate many background tasks and display their progress in real time in the terminal. Each task runs in its own goroutine and sends updates via channels. Use fan-in to collect progress, and a rate-limited ticker to refresh the display. Control execution with context and avoid race conditions with proper locking. Test graceful shutdown and design for no leaks. Add benchmark for tick rate impact on performance.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Functions",
      "Slices",
      "Structs",
      "Pointers",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Make-New",
      "Packages",
      "Imports",
      "Print-Scan",
      "Godoc",
      "Time-Scheduling",
      "Go Tools",
      "Defer"
    ]
  },
  {
    "id": 36,
    "name": "Async Currency Exchange Tracker",
    "challenge": 16,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Create an app that fetches and updates currency exchange rates from multiple APIs concurrently. Use goroutines for each provider, fan-in to aggregate updates, and buffered channels for results. Context manages global timeout and graceful shutdown. Debounce updates and rate-limit providers with ticker channels. Track retries and memory footprint. Provide coverage for fan-in logic and test mock APIs with context cancel.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Constants",
      "Functions",
      "Slices",
      "Maps",
      "Structs",
      "Interfaces",
      "Pointers",
      "Error Handling",
      "Generics",
      "Packages",
      "Imports",
      "Print-Scan",
      "Defer",
      "Time-Scheduling",
      "Godoc",
      "Go Tools"
    ]
  },
  {
    "id": 37,
    "name": "Parallel Audio Transcoder",
    "challenge": 17,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Build a CLI tool to convert a folder of audio files (e.g., `.wav` → `.mp3`) concurrently. Use a worker pool and buffered channels to queue work. Use context to abort long jobs, and graceful shutdown. Benchmark throughput and guard against leaks with profiling. Retry failed conversions with exponential backoff. Use channels to monitor progress in real time and include mock transcoder for testing.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Functions",
      "Pointers",
      "Slices",
      "Maps",
      "Structs",
      "Error Handling",
      "Interfaces",
      "Generics",
      "Packages",
      "Imports",
      "Make-New",
      "Print-Scan",
      "Defer",
      "Time-Scheduling",
      "Godoc",
      "Go Tools"
    ]
  },
  {
    "id": 38,
    "name": "Real-Time Voting System (Local CLI)",
    "challenge": 18,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Build a terminal voting system that allows many concurrent participants to vote in real-time. Each participant runs in a goroutine. The votes are submitted via channels and counted via fan-in. Prevent duplicate votes with safe concurrent maps. Use context to handle session timeout. Broadcast updated results to all terminals. Ensure clean exit and provide coverage for vote processing and leak detection.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Functions",
      "Maps",
      "Slices",
      "Structs",
      "Interfaces",
      "Error Handling",
      "Pointers",
      "Generics",
      "Packages",
      "Imports",
      "Print-Scan",
      "Defer",
      "Make-New",
      "Time-Scheduling",
      "Go Tools",
      "Godoc"
    ]
  },
  {
    "id": 39,
    "name": "Goroutine Lifecycle Debugger",
    "challenge": 19,
    "level": 2,
    "completed": false,
    "published": false,
    "description": "Create a dev tool that lets you start, monitor, cancel, and analyze goroutines during their lifecycle. Track running routines via IDs and simulate control via terminal. Use buffered channels to receive debug info, fan-in for reporting, and select for timed updates. Use WaitGroups for lifecycle, and graceful shutdown with context. Profile memory, test for blocking leaks, and document all primitives in godoc.",
    "tags": [
      "Goroutines",
      "Buffered Channels",
      "Unbuffered Channels",
      "Select Statement",
      "WaitGroups",
      "Mutex",
      "RWMutex",
      "Context",
      "Channel Direction",
      "Closing Channels",
      "Blocking Behavior",
      "nil Channels",
      "Channel Leaks",
      "Fan-In",
      "Fan-Out",
      "Pipelining",
      "Producer Consumer",
      "Tee Pattern",
      "Multiplexing",
      "Broadcast",
      "Worker Pool",
      "Job Queue",
      "Semaphore",
      "Limiting Concurrency",
      "Rate Limiting",
      "Timeout Channels",
      "Timers",
      "Debouncing",
      "Graceful Shutdown",
      "Retry Backoff",
      "Safe Concurrent Maps",
      "Memory Leaks",
      "Escape Analysis",
      "Garbage Collection",
      "Benchmarking",
      "Profiling",
      "Table Testing",
      "Mocking",
      "Code Coverage",
      "time.After",
      "Tickers",
      "time.Ticker",
      "time.Timer",
      "Sleep",
      "Using Context Timeout",
      "Combining Context and Timeouts",
      "Avoid Goroutine Leaks",
      "Detect Closed Channels",
      "Channel Blocking / Non-blocking",
      "Rate-limiting using Ticker",
      "Fan-In / Fan-Out Pattern",
      "Job Queues with Buffering",
      "Broadcast Pattern",
      "Variables",
      "Functions",
      "Pointers",
      "Maps",
      "Structs",
      "Slices",
      "Interfaces",
      "Generics",
      "Error Handling",
      "Packages",
      "Imports",
      "Print-Scan",
      "Godoc",
      "Defer",
      "Go Tools",
      "Make-New",
      "Time-Scheduling"
    ]
  },
  {
  "id": 40,
  "name": "Concurrent Pipeline Task Executor",
  "challenge": 20,
  "level": 2,
  "completed": false,
  "published": false,
  "description": "Create a task system where each step in a job runs as a stage in a pipeline using channels. Each stage runs in a goroutine. Use fan-in/fan-out to pass intermediate results. Apply rate limits to specific stages. Use context for timeout, channels for cancellation, and WaitGroups to control lifecycle. Benchmark task throughput. Test all pipes for deadlock and close-safety. Ensure coverage of all concurrency components.",
  "tags": [
    "Goroutines", "Buffered Channels", "Unbuffered Channels", "Select Statement", "WaitGroups",
    "Mutex", "RWMutex", "Context", "Channel Direction", "Closing Channels", "Blocking Behavior",
    "nil Channels", "Channel Leaks", "Fan-In", "Fan-Out", "Pipelining", "Producer Consumer",
    "Tee Pattern", "Multiplexing", "Broadcast", "Worker Pool", "Job Queue", "Semaphore",
    "Limiting Concurrency", "Rate Limiting", "Timeout Channels", "Timers", "Debouncing",
    "Graceful Shutdown", "Retry Backoff", "Safe Concurrent Maps", "Memory Leaks",
    "Escape Analysis", "Garbage Collection", "Benchmarking", "Profiling", "Table Testing",
    "Mocking", "Code Coverage", "time.After", "Tickers", "time.Ticker", "time.Timer", "Sleep",
    "Using Context Timeout", "Combining Context and Timeouts", "Avoid Goroutine Leaks",
    "Detect Closed Channels", "Channel Blocking / Non-blocking", "Rate-limiting using Ticker",
    "Fan-In / Fan-Out Pattern", "Job Queues with Buffering", "Broadcast Pattern",

    "Variables", "Functions", "Pointers", "Structs", "Slices", "Maps", "Interfaces",
    "Error Handling", "Generics", "Packages", "Imports", "Print-Scan", "Go Tools",
    "Time-Scheduling", "Godoc", "Make-New", "Defer"
  ]
},
{
  "id": 41,
  "name": "Flexible HTTP Client Builder",
  "challenge": 1,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Build an HTTP client library where users can configure timeouts, retries, logging, headers, and middleware using the functional options pattern. Use reflection to inspect input structs for headers and automatic marshaling. Include a custom logger and code-generated client stubs from struct tags. Add embedded files for default config templates. Provide CLI to test endpoints. Support plugin injection for custom transports.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Constants",
    "Basic Types",
    "Functions",
    "Pointers",
    "Interfaces",
    "Structs",
    "Error Handling",
    "Slices",
    "Maps",
    "Generics",
    "Packages",
    "Imports",
    "Defer",
    "Godoc",
    "Make-New",
    "Print-Scan",
    "Go Tools",
    "Time-Scheduling",
    "Goroutines",
    "WaitGroups",
    "Context",
    "Select Statement",
    "Timers",
    "Safe Concurrent Maps"
  ]
},
{
  "id": 42,
  "name": "go:generate-based JSON Schema Validator",
  "challenge": 2,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Create a tool that, given a Go struct, uses go:generate + codegen to auto-produce a JSON schema validator for its fields. Use reflection to get metadata, generate validation functions, and embed templates for code. Design CLI support for schema output. Tag fields with validation rules and build a custom Stringer for error printing. Support optional plugin modules for custom types.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Structs",
    "Interfaces",
    "Pointers",
    "Slices",
    "Maps",
    "Functions",
    "Generics",
    "Error Handling",
    "Packages",
    "Imports",
    "Make-New",
    "Defer",
    "Godoc",
    "Go Tools",
    "Print-Scan"
  ]
},
{
  "id": 43,
  "name": "Pluggable Logger Framework",
  "challenge": 3,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Create a flexible logger system where you can plug multiple loggers (file, stdout, JSON, remote) with middleware chaining. Use reflection to inspect context metadata, and embed default templates and output styles. Inject formatters with dependency injection and functional options. Allow building custom logging pipelines via plugin system. Generate default log adapters via go:generate.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Functions",
    "Interfaces",
    "Structs",
    "Error Handling",
    "Pointers",
    "Defer",
    "Make-New",
    "Packages",
    "Imports",
    "Print-Scan",
    "Godoc",
    "Go Tools",
    "Slices",
    "Maps"
  ]
},
{
  "id": 44,
  "name": "Advanced Task Runner CLI",
  "challenge": 4,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Build a CLI app that allows users to define tasks in YAML, and run them with support for plugins (compiled at runtime). Use reflection to bind YAML to struct definitions. Generate command handlers with go:generate, and support middlewares for task logging. Use embedded templates and build tags to toggle debug behavior. CLI should support custom commands and allow DI of task engines.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Functions",
    "Slices",
    "Maps",
    "Structs",
    "Pointers",
    "Interfaces",
    "Error Handling",
    "Make-New",
    "Packages",
    "Imports",
    "Defer",
    "Godoc",
    "Go Tools",
    "Print-Scan",
    "Time-Scheduling"
  ]
},
{
  "id": 45,
  "name": "Modular Linter CLI",
  "challenge": 5,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Build a modular Go linter that can be extended using plugins and build tags. Each linter rule is a plugin module and loaded dynamically. Use reflection for AST analysis, codegen for rule registration, and embed help files. Provide full CLI with task routing and logging middleware. Design dependency injection for passing rule context. Track rules via stringer and auto-generate help via go:generate.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Functions",
    "Interfaces",
    "Structs",
    "Error Handling",
    "Slices",
    "Maps",
    "Pointers",
    "Generics",
    "Packages",
    "Imports",
    "Defer",
    "Make-New",
    "Godoc",
    "Go Tools",
    "Print-Scan",
    "Time-Scheduling"
  ]
},{
  "id": 46,
  "name": "Dynamic Config Loader",
  "challenge": 6,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Create a dynamic configuration loader that reads YAML or JSON files and injects the data into the proper structs via reflection. Support versioning with build tags. Use go:generate to create schema validators. Provide CLI and logging middleware. Embed default templates. Plugins can be loaded to extend the config sources. Use dependency injection to inject file readers, cache layers, or remote loaders.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Constants",
    "Structs",
    "Interfaces",
    "Pointers",
    "Functions",
    "Slices",
    "Maps",
    "Error Handling",
    "Generics",
    "Packages",
    "Imports",
    "Defer",
    "Make-New",
    "Godoc",
    "Print-Scan",
    "Go Tools",
    "Time-Scheduling"
  ]
},
{
  "id": 47,
  "name": "Plugin-Based HTML Report Generator",
  "challenge": 7,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Develop a system that loads plugin modules to generate sections of an HTML report. Each plugin is dynamically loaded and uses reflection to inspect data models. Provide CLI to trigger report generation. Embed default CSS and HTML templates, support middleware for output transforms, and generate plugin bindings using go:generate. Use dependency injection to inject global context and formatter handlers.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Slices",
    "Maps",
    "Interfaces",
    "Error Handling",
    "Generics",
    "Packages",
    "Imports",
    "Print-Scan",
    "Defer",
    "Make-New",
    "Godoc",
    "Go Tools",
    "Time-Scheduling"
  ]
},
{
  "id": 48,
  "name": "Build-Time Feature Flags CLI",
  "challenge": 8,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Build a CLI tool where certain features are enabled or disabled based on build tags (e.g., `dev`, `enterprise`). Use code generation to insert the correct behavior per build context. Include embedded feature metadata, custom Stringers for describing flags, and a plugin system to extend features. Middleware controls access to commands. Add linter plugin to ensure correct tag usage.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Constants",
    "Functions",
    "Slices",
    "Maps",
    "Pointers",
    "Interfaces",
    "Structs",
    "Error Handling",
    "Packages",
    "Imports",
    "Print-Scan",
    "Make-New",
    "Defer",
    "Go Tools",
    "Godoc",
    "Time-Scheduling"
  ]
},
{
  "id": 49,
  "name": "Go Package Analyzer CLI",
  "challenge": 9,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Create a CLI tool that analyzes a Go package and extracts metrics such as number of types, exported identifiers, method counts, interface usage. Use reflection + AST inspection. Plugins can define custom metrics and add middleware analysis. Generate help from go:generate. Embed default rule sets and allow feature injection. Provide stringers for metrics output and build tags to toggle deep analysis.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Functions",
    "Structs",
    "Interfaces",
    "Pointers",
    "Maps",
    "Slices",
    "Generics",
    "Error Handling",
    "Packages",
    "Imports",
    "Print-Scan",
    "Make-New",
    "Defer",
    "Go Tools",
    "Godoc",
    "Time-Scheduling"
  ]
},
{
  "id": 50,
  "name": "File Processor DSL Framework",
  "challenge": 10,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Build a system that allows users to define file processing logic in a custom DSL (e.g., `when .ext == '.txt' do compress`). Load DSL rules via plugins. Use reflection to match file models, embed rules in template files, and build tag guards to enable/disable DSL execution. Provide code-generated command registration, logger middleware, and dependency-injected execution pipelines.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Functions",
    "Pointers",
    "Slices",
    "Maps",
    "Structs",
    "Interfaces",
    "Generics",
    "Error Handling",
    "Packages",
    "Imports",
    "Print-Scan",
    "Godoc",
    "Defer",
    "Go Tools",
    "Time-Scheduling"
  ]
},
{
  "id": 51,
  "name": "Reactive CLI Form Renderer",
  "challenge": 11,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Build a CLI form system where each field is defined by a plugin and reacts to previous input. Use reflection to bind values and go:generate to create validation. Support middleware for form processing and error messages. Plugin system allows field types (select, input, multi-line). Embed form templates, use stringers for display, and build tags to enable advanced styling. Inject custom formatters with DI.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Structs",
    "Functions",
    "Pointers",
    "Slices",
    "Maps",
    "Interfaces",
    "Error Handling",
    "Generics",
    "Packages",
    "Imports",
    "Print-Scan",
    "Defer",
    "Godoc",
    "Make-New",
    "Go Tools",
    "Time-Scheduling",
    "Goroutines",
    "Context",
    "Channel Direction",
    "Select Statement",
    "Debouncing"
  ]
},
{
  "id": 51,
  "name": "Reactive CLI Form Renderer",
  "challenge": 11,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Build a CLI form system where each field is defined by a plugin and reacts to previous input. Use reflection to bind values and go:generate to create validation. Support middleware for form processing and error messages. Plugin system allows field types (select, input, multi-line). Embed form templates, use stringers for display, and build tags to enable advanced styling. Inject custom formatters with DI.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Structs",
    "Functions",
    "Pointers",
    "Slices",
    "Maps",
    "Interfaces",
    "Error Handling",
    "Generics",
    "Packages",
    "Imports",
    "Print-Scan",
    "Defer",
    "Godoc",
    "Make-New",
    "Go Tools",
    "Time-Scheduling",
    "Goroutines",
    "Context",
    "Channel Direction",
    "Select Statement",
    "Debouncing"
  ]
},
{
  "id": 53,
  "name": "Dynamic CLI Router",
  "challenge": 13,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Design a CLI router that dynamically registers commands and handlers via go:generate and plugins. Use reflection to bind arguments to structs. Middleware controls access, logging, and validations. Provide embedded command help. Build tags toggle development vs production CLI. Stringer interface is used to describe command metadata. Use DI to inject behavior for test/real environments.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Interfaces",
    "Error Handling",
    "Packages",
    "Imports",
    "Slices",
    "Maps",
    "Generics",
    "Defer",
    "Godoc",
    "Print-Scan",
    "Make-New",
    "Go Tools",
    "Time-Scheduling"
  ]
},
{
  "id": 54,
  "name": "Themeable Terminal Dashboard",
  "challenge": 14,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Create a dashboard interface in the terminal that shows system stats or project KPIs. Embed themes, templates, and allow plugin widgets. Use build tags to enable dark/light mode support. Each widget is loaded via plugin. Use reflection for live config updates, dependency injection for widget control, and go:generate to scaffold default dashboards. Provide middleware to filter visibility by role or status.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Constants",
    "Functions",
    "Structs",
    "Pointers",
    "Slices",
    "Maps",
    "Interfaces",
    "Error Handling",
    "Generics",
    "Packages",
    "Imports",
    "Make-New",
    "Defer",
    "Godoc",
    "Print-Scan",
    "Time-Scheduling",
    "Go Tools",
    "Goroutines",
    "Context",
    "Tickers",
    "Timers"
  ]
},
{
  "id": 55,
  "name": "Modular Webhook Processor",
  "challenge": 15,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Build a webhook processor system where different endpoints (GitHub, Stripe, GitLab) are injected via plugins. Each webhook is validated and dispatched using middleware logic. Use reflection to parse headers and bodies dynamically. Add support for go:generate-based handler registration. Embed test payloads and provide custom stringers for logging. Allow users to build webhook modules and compile via plugin interface.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Structs",
    "Functions",
    "Pointers",
    "Interfaces",
    "Maps",
    "Slices",
    "Error Handling",
    "Generics",
    "Packages",
    "Imports",
    "Defer",
    "Godoc",
    "Make-New",
    "Print-Scan",
    "Go Tools",
    "Goroutines",
    "Context",
    "WaitGroups",
    "Safe Concurrent Maps",
    "Channel Direction"
  ]
},
{
  "id": 56,
  "name": "Custom Middleware Engine for CLI Apps",
  "challenge": 16,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Develop a middleware engine to use inside CLI commands: logging, validation, metrics, throttling. Each middleware is chainable via functional options. Use reflection to bind context values, embed default stacks, and allow go:generate to scaffold chains. Add support for DI of runtime flags and logging layers. Plugins can extend middleware at runtime. Provide stringer-based debugging output.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Functions",
    "Interfaces",
    "Pointers",
    "Structs",
    "Error Handling",
    "Packages",
    "Imports",
    "Print-Scan",
    "Slices",
    "Defer",
    "Make-New",
    "Generics",
    "Godoc",
    "Go Tools"
  ]
},
{
  "id": 57,
  "name": "Plugin-Based CLI Linter",
  "challenge": 17,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Build a CLI tool that lints Go files. Use reflection and AST inspection to find issues. Each linter rule is a plugin. Use code generation to register rules. Provide middleware for rule chaining and DI for rule context injection. Use build tags to enable/disable rules. Embed examples of bad/good code and stringer interface for reporting. Plugins can load dynamic linter logic.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Structs",
    "Functions",
    "Pointers",
    "Interfaces",
    "Error Handling",
    "Slices",
    "Packages",
    "Imports",
    "Print-Scan",
    "Generics",
    "Make-New",
    "Godoc",
    "Go Tools"
  ]
},
{
  "id": 58,
  "name": "Micro Plugin Manager",
  "challenge": 18,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Create a lightweight plugin manager that loads `.so` plugin files and runs exported handlers. Use reflection to validate handler signatures. Support plugin registration via go:generate. CLI should support install, remove, run. Use middleware for logging plugin lifecycle, and DI for managing environment variables. Embed plugin metadata and provide stringer interface for overview. Build tags separate test from production environments.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Functions",
    "Pointers",
    "Interfaces",
    "Error Handling",
    "Structs",
    "Slices",
    "Packages",
    "Imports",
    "Print-Scan",
    "Defer",
    "Make-New",
    "Godoc",
    "Go Tools"
  ]
},
{
  "id": 59,
  "name": "Static Site Generator",
  "challenge": 19,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Build a static site generator that takes markdown files and renders HTML using embedded templates. Use go:generate to produce layout scaffolding. Each layout block is a plugin. Use reflection to map metadata to HTML components. Inject render logic via DI. Embed CSS and JS defaults. Provide stringer-based diagnostics and build tag toggles (dev/prod). Middleware enables SEO, minification, and caching.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Constants",
    "Functions",
    "Structs",
    "Pointers",
    "Maps",
    "Slices",
    "Interfaces",
    "Error Handling",
    "Packages",
    "Imports",
    "Print-Scan",
    "Make-New",
    "Godoc",
    "Go Tools"
  ]
},
{
  "id": 60,
  "name": "Automated Test Generator",
  "challenge": 20,
  "level": 3,
  "completed": false,
  "published": false,
  "description": "Build a CLI tool that inspects Go structs and generates `*_test.go` files with table-driven tests for exported methods. Use go:generate and reflection to extract method info. Middleware defines test templates. Embed test boilerplates and use stringers for summaries. Inject test policies using DI. Plugins can define coverage strategies. Build tags toggle between fast and full test generation.",
  "tags": [
    "Functional Options",
    "Stringer Interface",
    "Reflection",
    "Code Generation",
    "Dependency Injection",
    "Middleware Design",
    "Build Tags",
    "Custom Linters",
    "CLI App",
    "Plugin System",
    "Custom Logger",
    "Embed Files",
    "Variables",
    "Structs",
    "Functions",
    "Interfaces",
    "Pointers",
    "Error Handling",
    "Slices",
    "Packages",
    "Imports",
    "Print-Scan",
    "Go Tools",
    "Make-New",
    "Godoc"
  ]
},
{
  "id": 61,
  "name": "User Auth API (JWT, OAuth2, Refresh Tokens)",
  "challenge": 1,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Build a complete user authentication system using JWT access + refresh tokens. Include signup, login, logout, email verification, password hashing, and token refresh. Support OAuth2 login (Google). Protect routes with middleware and rate limiting. Enable CORS, JSON error handling, and recovery. Use reverse proxy headers and HTTPS support. Provide HTML templates for login/verify and serve static assets.",
  "tags": [
    "REST API",
    "Routing",
    "JSON",
    "URL Params",
    "Headers",
    "Middleware",
    "Logging",
    "CORS",
    "Recovery",
    "JWT Auth",
    "Refresh Tokens",
    "Session Auth",
    "Validation",
    "Form Validation",
    "Secure Password Hashing",
    "Email Verification",
    "OAuth2",
    "HTML Templates",
    "Static Assets",
    "Rate Limiting",
    "HTTPS",
    "Reverse Proxy",
    "Pagination",
    "Sorting",
    "Variables",
    "Constants",
    "Functions",
    "Structs",
    "Pointers",
    "Maps",
    "Slices",
    "Interfaces",
    "Error Handling",
    "Packages",
    "Imports",
    "Generics",
    "Godoc",
    "Defer",
    "Make-New",
    "Print-Scan",
    "Go Tools",
    "Context",
    "Goroutines",
    "WaitGroups",
    "Select Statement",
    "time.After",
    "Tickers"
  ]
},
{
  "id": 62,
  "name": "Task Tracker API (Filter, Pagination, Upload)",
  "challenge": 2,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Create a REST API to manage tasks (CRUD). Support pagination, filtering by tag/status, and sorting by date. Implement JWT authentication, file uploads for attachments, and input validation with clear error messages. Add middleware for logging, rate limiting, recovery. Serve uploaded files from static directory. Build HTML templates for user dashboard and upload UI.",
  "tags": [
    "REST API",
    "Routing",
    "JSON",
    "URL Params",
    "Headers",
    "Middleware",
    "Logging",
    "CORS",
    "Recovery",
    "JWT Auth",
    "Session Auth",
    "Validation",
    "Form Validation",
    "Secure Password Hashing",
    "File Uploads",
    "Pagination",
    "Filtering",
    "Sorting",
    "HTML Templates",
    "Static Assets",
    "Rate Limiting",
    "HTTPS",
    "Reverse Proxy",
    "Refresh Tokens",
    "Variables",
    "Structs",
    "Functions",
    "Pointers",
    "Slices",
    "Maps",
    "Interfaces",
    "Error Handling",
    "Packages",
    "Imports",
    "Defer",
    "Make-New",
    "Generics",
    "Godoc",
    "Go Tools",
    "Context",
    "Goroutines",
    "Select Statement",
    "Timers"
  ]
},
{
  "id": 63,
  "name": "Blog API with SSR + Static Pages",
  "challenge": 3,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Build a blogging platform with RESTful endpoints to manage posts. Each post supports Markdown input, and is rendered via HTML templates (SSR). Admin panel includes auth, post creation with file uploads, pagination, and tag filters. Public site is served via static files with CORS, SEO metadata and HTML templates. Secure auth, recover from panics, and use build-time static asset compression.",
  "tags": [
    "REST API",
    "Routing",
    "JSON",
    "URL Params",
    "Headers",
    "Middleware",
    "Logging",
    "CORS",
    "Recovery",
    "JWT Auth",
    "Validation",
    "Form Validation",
    "Secure Password Hashing",
    "File Uploads",
    "Pagination",
    "Filtering",
    "Sorting",
    "HTML Templates",
    "Static Assets",
    "Rate Limiting",
    "HTTPS",
    "Reverse Proxy",
    "Session Auth",
    "Email Verification",
    "Variables",
    "Structs",
    "Functions",
    "Pointers",
    "Interfaces",
    "Error Handling",
    "Slices",
    "Maps",
    "Generics",
    "Make-New",
    "Packages",
    "Imports",
    "Defer",
    "Print-Scan",
    "Go Tools",
    "Goroutines",
    "Context",
    "Tickers",
    "time.After"
  ]
},
{
  "id": 64,
  "name": "E-Commerce API (Cart, Session, Uploads)",
  "challenge": 4,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Develop an API for an e-commerce platform supporting products, cart, checkout, and image uploads. Use session-based auth with secure cookies, form validation, and user management. Upload product images via multipart/form-data. Add pagination, search, and tag filters. Serve images from static directory. Build HTML templates for product pages, and reverse proxy config with HTTPS support.",
  "tags": [
    "REST API",
    "Routing",
    "JSON",
    "URL Params",
    "Headers",
    "Middleware",
    "Logging",
    "CORS",
    "Recovery",
    "Session Auth",
    "Validation",
    "Form Validation",
    "Secure Password Hashing",
    "File Uploads",
    "Pagination",
    "Filtering",
    "Sorting",
    "HTML Templates",
    "Static Assets",
    "Rate Limiting",
    "HTTPS",
    "Reverse Proxy",
    "Email Verification",
    "JWT Auth",
    "Variables",
    "Functions",
    "Structs",
    "Slices",
    "Pointers",
    "Maps",
    "Interfaces",
    "Error Handling",
    "Packages",
    "Imports",
    "Make-New",
    "Generics",
    "Defer",
    "Godoc",
    "Print-Scan",
    "Go Tools",
    "Context",
    "Goroutines",
    "time.Timer"
  ]
},
{
  "id": 65,
  "name": "Realtime Chat API (WebSockets + Auth)",
  "challenge": 5,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Create a chat application backend using WebSockets. Authenticated users can join rooms, send and receive messages in real-time. Use JWT-based auth for login and validate tokens in upgrade middleware. Add logging, CORS, and panic recovery. Build an HTML interface with embedded templates and serve static assets. Track online users, broadcast with channels, and auto-reconnect logic with rate limiting.",
  "tags": [
    "REST API",
    "Routing",
    "JSON",
    "Headers",
    "Middleware",
    "Logging",
    "CORS",
    "Recovery",
    "JWT Auth",
    "Validation",
    "Form Validation",
    "Rate Limiting",
    "HTML Templates",
    "Static Assets",
    "HTTPS",
    "Reverse Proxy",
    "Session Auth",
    "WebSockets",
    "Email Verification",
    "Pagination",
    "Sorting",
    "URL Params",
    "Refresh Tokens",
    "Secure Password Hashing",
    "Variables",
    "Goroutines",
    "Channels Basics",
    "Select Statement",
    "Context",
    "Functions",
    "Structs",
    "Interfaces",
    "Error Handling",
    "Slices",
    "Pointers",
    "Packages",
    "Imports",
    "Go Tools",
    "Print-Scan",
    "Make-New",
    "Generics",
    "Defer",
    "Godoc"
  ]
},{
  "id": 66,
  "name": "Admin Dashboard (RBAC + Metrics)",
  "challenge": 6,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Create an admin dashboard showing metrics and stats. Use JWT-based role access with `admin`, `editor`, and `viewer` roles. Add protected endpoints for user management. Use CORS, pagination, filtering, and sorting. Track login history and actions. HTML templates render tables and charts. Secure passwords, add middleware for logging, rate limiting, and panic recovery. Serve frontend with static assets and HTTPS.",
  "tags": [
    "REST API",
    "Routing",
    "JSON",
    "URL Params",
    "Headers",
    "Middleware",
    "Logging",
    "CORS",
    "Recovery",
    "JWT Auth",
    "Session Auth",
    "Validation",
    "Form Validation",
    "Secure Password Hashing",
    "Pagination",
    "Filtering",
    "Sorting",
    "HTML Templates",
    "Static Assets",
    "Rate Limiting",
    "HTTPS",
    "Reverse Proxy",
    "Refresh Tokens",
    "Email Verification",
    "Variables",
    "Constants",
    "Structs",
    "Interfaces",
    "Functions",
    "Slices",
    "Pointers",
    "Error Handling",
    "Packages",
    "Imports",
    "Defer",
    "Make-New",
    "Go Tools",
    "Generics",
    "Print-Scan",
    "Context"
  ]
},
{
  "id": 67,
  "name": "Contact Form API (Email Delivery + Validation)",
  "challenge": 7,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Create a contact form with frontend and backend. The backend validates input, stores message, and sends email using SMTP or Mailgun. Rate-limit form submissions and prevent XSS/CSRF. Serve the form via HTML template. Include file upload support and server-side form validation. Protect API with HTTPS, recover panics, log every submission, and serve static files (JS/CSS).",
  "tags": [
    "REST API",
    "Routing",
    "JSON",
    "Headers",
    "URL Params",
    "Middleware",
    "Logging",
    "CORS",
    "Recovery",
    "Validation",
    "Form Validation",
    "Secure Password Hashing",
    "File Uploads",
    "Rate Limiting",
    "HTML Templates",
    "Static Assets",
    "HTTPS",
    "Reverse Proxy",
    "Email Verification",
    "Pagination",
    "JWT Auth",
    "Refresh Tokens",
    "Session Auth",
    "Sorting",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Slices",
    "Interfaces",
    "Error Handling",
    "Packages",
    "Imports",
    "Print-Scan",
    "Defer",
    "Generics",
    "Make-New",
    "Godoc",
    "Go Tools",
    "Context"
  ]
},
{
  "id": 68,
  "name": "Go + React Fullstack Notes App",
  "challenge": 8,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Build a fullstack notes app with Go as the API and React as the frontend. Use JWT for auth, CRUD routes for notes, and filtering. Backend provides pagination and tag-based search. Protect API with middleware, logging, rate limits, and validation. Serve React from static assets folder. Use HTTPS, reverse proxy support, and recovery middleware. Upload images inside notes (optional).",
  "tags": [
    "REST API", "Routing", "JSON", "URL Params", "Headers", "Middleware", "Logging", "CORS", "Recovery",
    "JWT Auth", "Validation", "Form Validation", "Pagination", "Filtering", "Sorting",
    "Secure Password Hashing", "File Uploads", "Static Assets", "Rate Limiting",
    "HTML Templates", "HTTPS", "Reverse Proxy", "Session Auth", "Refresh Tokens",

    "Variables", "Structs", "Functions", "Pointers", "Slices", "Maps", "Interfaces", "Error Handling",
    "Packages", "Imports", "Go Tools", "Defer", "Print-Scan", "Make-New", "Generics", "Context",
    "Goroutines"
  ]
}
,
{
  "id": 69,
  "name": "SSE Feed API (Live Events)",
  "challenge": 9,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Create a live event feed API using Server-Sent Events (SSE). The user subscribes with a JWT, receives live updates filtered by topic. Backend exposes a REST endpoint to publish events. Use CORS, recovery, validation, and middleware. Rate limit publishing and manage SSE clients via channels. Serve frontend via HTML templates. HTTPS and reverse proxy setup required.",
  "tags": [
    "REST API",
    "Routing",
    "JSON",
    "Headers",
    "Middleware",
    "Logging",
    "CORS",
    "Recovery",
    "JWT Auth",
    "Validation",
    "Form Validation",
    "Rate Limiting",
    "Static Assets",
    "HTML Templates",
    "HTTPS",
    "Reverse Proxy",
    "Pagination",
    "Filtering",
    "Sorting",
    "Session Auth",
    "Refresh Tokens",
    "Secure Password Hashing",
    "SSE",
    "Email Verification",
    "Variables",
    "Functions",
    "Goroutines",
    "Channels Basics",
    "Select Statement",
    "Context",
    "Interfaces",
    "Structs",
    "Packages",
    "Imports",
    "Defer",
    "Go Tools",
    "Print-Scan"
  ]
},
{
  "id": 70,
  "name": "File Sharing API (Expiring Links + Auth)",
  "challenge": 10,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Create a secure file sharing system. Users upload files and receive a short-lived download link. Use JWT for user auth and expiring signed URLs for downloads. File uploads are stored with metadata. Rate limit uploads/downloads. Provide admin HTML templates to list/manage files. Static assets serve frontend. HTTPS required. Secure password hashing for user registration.",
  "tags": [
    "REST API",
    "Routing",
    "JSON",
    "Headers",
    "Middleware",
    "Logging",
    "CORS",
    "Recovery",
    "JWT Auth",
    "Validation",
    "Form Validation",
    "File Uploads",
    "Rate Limiting",
    "Pagination",
    "Sorting",
    "Secure Password Hashing",
    "HTML Templates",
    "Static Assets",
    "HTTPS",
    "Reverse Proxy",
    "Refresh Tokens",
    "Session Auth",
    "Email Verification",
    "URL Params",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Slices",
    "Interfaces",
    "Error Handling",
    "Packages",
    "Imports",
    "Print-Scan",
    "Defer",
    "Generics",
    "Make-New",
    "Go Tools",
    "Context"
  ]
},
{
  "id": 71,
  "name": "Multi-Tenant API Platform",
  "challenge": 11,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Build a multi-tenant API platform where each user or organization has a separate subdomain (e.g., team1.example.com). Authenticate with JWT, store tenant info in context. Apply per-tenant rate limits and CORS rules. Serve isolated static assets and templates. Use HTTPS, reverse proxy headers, form validation, and panic recovery middleware. Support user switching and file uploads.",
  "tags": [
    "REST API",
    "Routing",
    "Headers",
    "JSON",
    "URL Params",
    "CORS",
    "JWT Auth",
    "Session Auth",
    "Validation",
    "Form Validation",
    "Pagination",
    "Filtering",
    "Sorting",
    "Secure Password Hashing",
    "File Uploads",
    "Static Assets",
    "HTML Templates",
    "Rate Limiting",
    "HTTPS",
    "Reverse Proxy",
    "Logging",
    "Middleware",
    "Recovery",
    "Email Verification",
    "Refresh Tokens",
    "Variables",
    "Functions",
    "Structs",
    "Interfaces",
    "Pointers",
    "Slices",
    "Maps",
    "Packages",
    "Imports",
    "Print-Scan",
    "Go Tools",
    "Make-New",
    "Defer",
    "Godoc",
    "Context",
    "Goroutines"
  ]
},
{
  "id": 72,
  "name": "Scheduling API with Notifications",
  "challenge": 12,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Build an API for scheduling events/reminders. Authenticated users can create, view, and update events. System sends notifications via email and SSE to subscribed clients. Use JWT auth, panic recovery, rate limiting, static HTML dashboard, CORS, pagination, and filtering. Upload ICS files. Serve via reverse proxy with HTTPS. Use validation and middleware for each route.",
  "tags": [
    "REST API",
    "JWT Auth",
    "Routing",
    "JSON",
    "Form Validation",
    "Validation",
    "Rate Limiting",
    "SSE",
    "Email Verification",
    "Headers",
    "CORS",
    "Middleware",
    "Logging",
    "Recovery",
    "Static Assets",
    "HTML Templates",
    "Pagination",
    "Filtering",
    "Sorting",
    "Secure Password Hashing",
    "File Uploads",
    "Session Auth",
    "Refresh Tokens",
    "HTTPS",
    "Reverse Proxy",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Interfaces",
    "Slices",
    "Error Handling",
    "Generics",
    "Go Tools",
    "Print-Scan",
    "Make-New",
    "Defer",
    "Context",
    "Goroutines",
    "Select Statement"
  ]
},
{
  "id": 73,
  "name": "Fullstack Portfolio Site + Admin Panel",
  "challenge": 13,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Create a personal portfolio site with a public view and a private admin dashboard. Admin can manage projects, blog posts, and contact form responses. Use form validation, JWT auth, file uploads, pagination, filtering. Pages are rendered with Go HTML templates and styled via static assets. Add reverse proxy and HTTPS setup, rate limiting, logging and panic recovery middleware.",
  "tags": [
    "REST API",
    "Routing",
    "JSON",
    "Headers",
    "CORS",
    "Logging",
    "Middleware",
    "Validation",
    "Form Validation",
    "JWT Auth",
    "Session Auth",
    "Secure Password Hashing",
    "File Uploads",
    "Pagination",
    "Filtering",
    "Sorting",
    "Static Assets",
    "HTML Templates",
    "Recovery",
    "Rate Limiting",
    "HTTPS",
    "Reverse Proxy",
    "Email Verification",
    "URL Params",
    "Refresh Tokens",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Slices",
    "Interfaces",
    "Maps",
    "Error Handling",
    "Packages",
    "Imports",
    "Make-New",
    "Print-Scan",
    "Go Tools",
    "Godoc",
    "Defer",
    "Context"
  ]
},
{
  "id": 74,
  "name": "Invoice API (PDF Export + Auth)",
  "challenge": 14,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Create a REST API to manage clients and invoices. Users can login with JWT and create, update, delete invoices. Export invoices as downloadable PDFs. Use file upload for logos, form validation, pagination, sorting. Email invoices with SMTP or Mailgun. Use secure password hashing, static HTML templates, rate limiting, reverse proxy headers, and panic recovery middleware.",
  "tags": [
    "REST API",
    "Routing",
    "JSON",
    "Headers",
    "Middleware",
    "CORS",
    "Logging",
    "Recovery",
    "Validation",
    "Form Validation",
    "JWT Auth",
    "Session Auth",
    "Secure Password Hashing",
    "Pagination",
    "Sorting",
    "File Uploads",
    "Email Verification",
    "Static Assets",
    "HTML Templates",
    "Rate Limiting",
    "HTTPS",
    "Reverse Proxy",
    "Refresh Tokens",
    "URL Params",
    "Variables",
    "Functions",
    "Pointers",
    "Slices",
    "Structs",
    "Interfaces",
    "Error Handling",
    "Packages",
    "Imports",
    "Make-New",
    "Defer",
    "Print-Scan",
    "Context",
    "Go Tools"
  ]
},
{
  "id": 75,
  "name": "Go + HTMX CRUD Dashboard",
  "challenge": 15,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Create a full CRUD dashboard using Go as backend and HTMX for frontend interaction (no full page reload). Use JWT for authentication, form validation, and HTML templates for rendering. Include filtering, pagination, sorting. Protect routes via middleware and implement panic recovery. Add upload support, rate limiting, HTTPS, and serve via reverse proxy. Ensure real-time UX with minimal JS.",
  "tags": [
    "REST API",
    "Routing",
    "JSON",
    "Headers",
    "JWT Auth",
    "Validation",
    "Form Validation",
    "Pagination",
    "Filtering",
    "Sorting",
    "HTML Templates",
    "Static Assets",
    "CORS",
    "Middleware",
    "Recovery",
    "Logging",
    "HTTPS",
    "Reverse Proxy",
    "File Uploads",
    "Session Auth",
    "Secure Password Hashing",
    "Refresh Tokens",
    "Rate Limiting",
    "Email Verification",
    "Variables",
    "Structs",
    "Functions",
    "Pointers",
    "Slices",
    "Maps",
    "Interfaces",
    "Packages",
    "Imports",
    "Print-Scan",
    "Make-New",
    "Go Tools",
    "Defer",
    "Godoc",
    "Context",
    "Goroutines"
  ]
},
{
  "id": 75,
  "name": "Go + HTMX CRUD Dashboard",
  "challenge": 15,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Create a full CRUD dashboard using Go as backend and HTMX for frontend interaction (no full page reload). Use JWT for authentication, form validation, and HTML templates for rendering. Include filtering, pagination, sorting. Protect routes via middleware and implement panic recovery. Add upload support, rate limiting, HTTPS, and serve via reverse proxy. Ensure real-time UX with minimal JS.",
  "tags": [
    "REST API",
    "Routing",
    "JSON",
    "Headers",
    "JWT Auth",
    "Validation",
    "Form Validation",
    "Pagination",
    "Filtering",
    "Sorting",
    "HTML Templates",
    "Static Assets",
    "CORS",
    "Middleware",
    "Recovery",
    "Logging",
    "HTTPS",
    "Reverse Proxy",
    "File Uploads",
    "Session Auth",
    "Secure Password Hashing",
    "Refresh Tokens",
    "Rate Limiting",
    "Email Verification",
    "Variables",
    "Structs",
    "Functions",
    "Pointers",
    "Slices",
    "Maps",
    "Interfaces",
    "Packages",
    "Imports",
    "Print-Scan",
    "Make-New",
    "Go Tools",
    "Defer",
    "Godoc",
    "Context",
    "Goroutines"
  ]
},
{
  "id": 76,
  "name": "GraphQL API for Courses",
  "challenge": 16,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Create a full-featured GraphQL API to manage a course platform. Users can query, mutate, and subscribe to course events. Auth is handled via JWT. Rate limiting and panic recovery middleware are used. Users can upload files (PDF, images) for course material. GraphQL subscriptions push real-time updates to clients. Secure all routes, serve admin panel with HTML templates, static assets, and enable CORS + reverse proxy support.",
  "tags": [
    "REST API",
    "Routing",
    "Headers",
    "JWT Auth",
    "Validation",
    "Form Validation",
    "Secure Password Hashing",
    "File Uploads",
    "Pagination",
    "Sorting",
    "Static Assets",
    "HTML Templates",
    "Rate Limiting",
    "CORS",
    "Logging",
    "Middleware",
    "Recovery",
    "HTTPS",
    "Reverse Proxy",
    "Session Auth",
    "Email Verification",
    "Refresh Tokens",
    "JSON",
    "URL Params",
    "GraphQL",
    "Variables",
    "Functions",
    "Pointers",
    "Slices",
    "Maps",
    "Structs",
    "Interfaces",
    "Error Handling",
    "Packages",
    "Imports",
    "Print-Scan",
    "Go Tools",
    "Make-New",
    "Defer",
    "Context",
    "Goroutines",
    "Channels Basics"
  ]
},
{
  "id": 78,
  "name": "Markdown Blog (SSR + Upload)",
  "challenge": 18,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Build a Markdown-based blog where admins can login and create posts via HTML forms. Posts are rendered using HTML templates (SSR). Upload cover images, paginate blog feed, add filters and search. Protect dashboard with JWT or session auth. Serve static assets, enable CORS, panic recovery, and rate limiting. Use HTTPS with reverse proxy setup. Include secure password hashing.",
  "tags": [
    "REST API",
    "Routing",
    "JWT Auth",
    "Session Auth",
    "Validation",
    "Form Validation",
    "Secure Password Hashing",
    "File Uploads",
    "Pagination",
    "Filtering",
    "Sorting",
    "Static Assets",
    "HTML Templates",
    "Logging",
    "Middleware",
    "Recovery",
    "CORS",
    "Rate Limiting",
    "HTTPS",
    "Reverse Proxy",
    "Refresh Tokens",
    "Email Verification",
    "JSON",
    "Headers",
    "URL Params",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Interfaces",
    "Slices",
    "Maps",
    "Error Handling",
    "Packages",
    "Imports",
    "Print-Scan",
    "Go Tools",
    "Defer",
    "Make-New",
    "Context"
  ]
},
{
  "id": 79,
  "name": "Voting System API (Upvote/Downvote)",
  "challenge": 19,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Create a backend for a voting system (like Reddit). Users can register, login, and upvote/downvote posts and comments. All interactions are protected by JWT. Prevent double voting with server-side validation. Display sorted content based on votes. Include rate limiting, CORS, middleware, pagination, filtering, file upload for avatars, HTML templates, static frontend, HTTPS and reverse proxy setup.",
  "tags": [
    "REST API",
    "Routing",
    "JWT Auth",
    "Validation",
    "Form Validation",
    "Pagination",
    "Filtering",
    "Sorting",
    "File Uploads",
    "Static Assets",
    "HTML Templates",
    "Rate Limiting",
    "Recovery",
    "CORS",
    "Middleware",
    "Logging",
    "Headers",
    "HTTPS",
    "Reverse Proxy",
    "Session Auth",
    "Secure Password Hashing",
    "Refresh Tokens",
    "Email Verification",
    "JSON",
    "URL Params",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Slices",
    "Interfaces",
    "Error Handling",
    "Packages",
    "Imports",
    "Print-Scan",
    "Go Tools",
    "Make-New",
    "Defer",
    "Context",
    "Goroutines"
  ]
},
{
  "id": 80,
  "name": "Fullstack Kanban Board (React + Go)",
  "challenge": 20,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Build a fullstack Kanban board app. Use Go for the backend REST API and React for the drag-and-drop frontend. Support JWT auth, CRUD for boards/tasks/columns. Apply filtering, sorting, and pagination. Upload images/files per task. Protect API with middleware and rate limiting. Serve React from static folder, secure API with HTTPS and reverse proxy. Add panic recovery and logging.",
  "tags": [
    "REST API",
    "Routing",
    "JWT Auth",
    "Session Auth",
    "Validation",
    "Form Validation",
    "Pagination",
    "Filtering",
    "Sorting",
    "File Uploads",
    "Static Assets",
    "HTML Templates",
    "Rate Limiting",
    "Recovery",
    "CORS",
    "Middleware",
    "Logging",
    "HTTPS",
    "Reverse Proxy",
    "Refresh Tokens",
    "Secure Password Hashing",
    "Email Verification",
    "JSON",
    "Headers",
    "URL Params",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Slices",
    "Maps",
    "Interfaces",
    "Error Handling",
    "Packages",
    "Imports",
    "Print-Scan",
    "Make-New",
    "Defer",
    "Go Tools",
    "Context",
    "Goroutines"
  ]
},
{
  "id": 80,
  "name": "Fullstack Kanban Board (React + Go)",
  "challenge": 20,
  "level": 4,
  "completed": false,
  "published": false,
  "description": "Build a fullstack Kanban board app. Use Go for the backend REST API and React for the drag-and-drop frontend. Support JWT auth, CRUD for boards/tasks/columns. Apply filtering, sorting, and pagination. Upload images/files per task. Protect API with middleware and rate limiting. Serve React from static folder, secure API with HTTPS and reverse proxy. Add panic recovery and logging.",
  "tags": [
    "REST API",
    "Routing",
    "JWT Auth",
    "Session Auth",
    "Validation",
    "Form Validation",
    "Pagination",
    "Filtering",
    "Sorting",
    "File Uploads",
    "Static Assets",
    "HTML Templates",
    "Rate Limiting",
    "Recovery",
    "CORS",
    "Middleware",
    "Logging",
    "HTTPS",
    "Reverse Proxy",
    "Refresh Tokens",
    "Secure Password Hashing",
    "Email Verification",
    "JSON",
    "Headers",
    "URL Params",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Slices",
    "Maps",
    "Interfaces",
    "Error Handling",
    "Packages",
    "Imports",
    "Print-Scan",
    "Make-New",
    "Defer",
    "Go Tools",
    "Context",
    "Goroutines"
  ]
},{
  "id": 81,
  "name": "User Management API (PostgreSQL Fullstack)",
  "challenge": 1,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Create a secure user management API using PostgreSQL and Go. Use GORM or sqlx to connect. Support signup/login, email verification, password hashing, and role management. Implement transactions for signup + verification flow. Use parameterized queries and create database indexes for email/username. Handle NULLs for optional fields. Write unit tests using test containers.",
  "tags": [
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Query Optimization",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "JSONB",
    "NULL Handling",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "REST API",
    "JWT Auth",
    "Session Auth",
    "Validation",
    "Form Validation",
    "Routing",
    "Logging",
    "Rate Limiting",
    "File Uploads",
    "Static Assets",
    "HTML Templates",
    "Secure Password Hashing",
    "Headers",
    "HTTPS",
    "Reverse Proxy",
    "Middleware",
    "Recovery",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Interfaces",
    "Maps",
    "Slices",
    "Packages",
    "Imports",
    "Print-Scan",
    "Make-New",
    "Defer",
    "Go Tools",
    "Context"
  ]
}
,
{
  "id": 83,
  "name": "Product Catalog API (Search + Fulltext)",
  "challenge": 3,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Build an API for managing a product catalog with advanced filtering and full-text search. Use PostgreSQL fulltext indexes on name and description. Use GORM/sqlx for ORM. Implement seeding with sample products. Support sorting, pagination, and filters by category/price range. Use prepared queries and optimize joins. Secure endpoints with JWT and provide a SSR frontend using Go templates.",
  "tags": [
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Query Optimization",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "JSONB",
    "NULL Handling",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "Transactions",
    "REST API",
    "JWT Auth",
    "Pagination",
    "Filtering",
    "Sorting",
    "Rate Limiting",
    "Validation",
    "Form Validation",
    "Static Assets",
    "HTML Templates",
    "File Uploads",
    "Secure Password Hashing",
    "CORS",
    "Recovery",
    "Logging",
    "Headers",
    "Routing",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Slices",
    "Interfaces",
    "Maps",
    "Go Tools",
    "Packages",
    "Imports",
    "Context"
  ]
},
{
  "id": 84,
  "name": "Audit Logging System (Triggers + JSONB)",
  "challenge": 4,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Create a system that records audit logs for any action on the platform (e.g., updates, deletes). Use PostgreSQL triggers to automatically log changes. Store logs with JSONB metadata and user context. Create views to query logs efficiently. Optimize with indexes. Write test coverage using test containers and ensure the DB user has limited privileges.",
  "tags": [
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Query Optimization",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "JSONB",
    "NULL Handling",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "REST API",
    "JWT Auth",
    "Logging",
    "Middleware",
    "Recovery",
    "Headers",
    "Validation",
    "Pagination",
    "Sorting",
    "HTTPS",
    "Reverse Proxy",
    "Email Verification",
    "Variables",
    "Functions",
    "Structs",
    "Interfaces",
    "Pointers",
    "Maps",
    "Slices",
    "Go Tools",
    "Context",
    "Packages",
    "Imports",
    "Defer"
  ]
},
{
  "id": 85,
  "name": "Multi-Table Transactional API",
  "challenge": 5,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Create an API that performs atomic operations across multiple tables (e.g., create order, deduct stock, create invoice). Ensure all steps are wrapped in a transaction with rollback on failure. Use prepared statements and constraints. Handle NULLs gracefully. Add DB-level validation and use indexes. Run tests using test containers and ensure the DB user has least privilege rights.",
  "tags": [
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Query Optimization",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "NULL Handling",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "JSONB",
    "REST API",
    "JWT Auth",
    "Validation",
    "Form Validation",
    "Rate Limiting",
    "Pagination",
    "Sorting",
    "CORS",
    "Logging",
    "Recovery",
    "Headers",
    "HTTPS",
    "Reverse Proxy",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Slices",
    "Interfaces",
    "Error Handling",
    "Go Tools",
    "Packages",
    "Imports",
    "Context",
    "Make-New",
    "Defer"
  ]
},
{
  "id": 85,
  "name": "Multi-Table Transactional API",
  "challenge": 5,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Create an API that performs atomic operations across multiple tables (e.g., create order, deduct stock, create invoice). Ensure all steps are wrapped in a transaction with rollback on failure. Use prepared statements and constraints. Handle NULLs gracefully. Add DB-level validation and use indexes. Run tests using test containers and ensure the DB user has least privilege rights.",
  "tags": [
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Query Optimization",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "NULL Handling",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "JSONB",
    "REST API",
    "JWT Auth",
    "Validation",
    "Form Validation",
    "Rate Limiting",
    "Pagination",
    "Sorting",
    "CORS",
    "Logging",
    "Recovery",
    "Headers",
    "HTTPS",
    "Reverse Proxy",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Slices",
    "Interfaces",
    "Error Handling",
    "Go Tools",
    "Packages",
    "Imports",
    "Context",
    "Make-New",
    "Defer"
  ]
},
{
  "id": 87,
  "name": "Analytics API (Materialized Views)",
  "challenge": 7,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Create an analytics API to expose metrics like total users, orders, revenue. Use PostgreSQL views and materialized views for aggregates. Schedule periodic refresh. Index views and aggregate columns. Optimize with parameterized queries and EXPLAIN plan review. Handle NULLs properly. Write integration tests using test containers. Secure with JWT and restrict DB user to read-only where possible.",
  "tags": [
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Query Optimization",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "NULL Handling",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "Transactions",
    "JSONB",
    "REST API",
    "JWT Auth",
    "Pagination",
    "Filtering",
    "Sorting",
    "HTTPS",
    "Reverse Proxy",
    "Logging",
    "CORS",
    "Headers",
    "Validation",
    "Form Validation",
    "Recovery",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Interfaces",
    "Packages",
    "Imports",
    "Context",
    "Go Tools",
    "Make-New",
    "Defer"
  ]
},
{
  "id": 88,
  "name": "Job Scheduler API",
  "challenge": 8,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Develop an API for deferred job scheduling. Store jobs with execution time, retry count, and JSONB parameters. Use transactions to atomically pick and mark jobs. Support retry logic and exponential backoff. Index scheduled_at and status. Write test coverage using test containers. Restrict DB role permissions. Provide REST endpoints and middleware with JWT-based auth.",
  "tags": [
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "JSONB",
    "NULL Handling",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "Query Optimization",
    "REST API",
    "JWT Auth",
    "Pagination",
    "Headers",
    "Validation",
    "Recovery",
    "Logging",
    "Rate Limiting",
    "HTTPS",
    "Reverse Proxy",
    "Email Verification",
    "Session Auth",
    "Variables",
    "Functions",
    "Pointers",
    "Slices",
    "Structs",
    "Maps",
    "Interfaces",
    "Packages",
    "Imports",
    "Context",
    "Defer",
    "Go Tools"
  ]
},
{
  "id": 89,
  "name": "Inventory Management System",
  "challenge": 9,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Build an inventory API where stock levels, products, and suppliers are related with foreign keys. Use ON DELETE/UPDATE constraints and indexes. Wrap critical operations in transactions. Support CSV imports for bulk stock updates. Handle NULLs, use JSONB for metadata. Write unit tests with test containers. Use a limited-privilege DB role and prepare statements.",
  "tags": [
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "JSONB",
    "NULL Handling",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "Query Optimization",
    "REST API",
    "JWT Auth",
    "Pagination",
    "Filtering",
    "Sorting",
    "File Uploads",
    "Rate Limiting",
    "Validation",
    "Form Validation",
    "Recovery",
    "Logging",
    "HTTPS",
    "Reverse Proxy",
    "CORS",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Slices",
    "Interfaces",
    "Packages",
    "Imports",
    "Go Tools",
    "Print-Scan",
    "Context"
  ]
},
{
  "id": 90,
  "name": "Audit Trail with History Tables",
  "challenge": 10,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Implement full audit trail per entity using history tables in PostgreSQL. Create triggers for INSERT/UPDATE/DELETE that record changes in *_history tables. Include user context via JSONB. Create efficient indexes on timestamps and entity ID. Support API endpoints to retrieve history. Use test containers and ensure all queries use parameterized statements. Secure API with JWT.",
  "tags": [
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Query Optimization",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "JSONB",
    "NULL Handling",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "REST API",
    "JWT Auth",
    "Pagination",
    "Sorting",
    "Filtering",
    "Validation",
    "Form Validation",
    "Rate Limiting",
    "Logging",
    "Headers",
    "Recovery",
    "HTTPS",
    "Reverse Proxy",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Slices",
    "Maps",
    "Interfaces",
    "Packages",
    "Imports",
    "Go Tools",
    "Context",
    "Make-New",
    "Defer"
  ]
},
{
  "id": 90,
  "name": "Audit Trail with History Tables",
  "challenge": 10,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Implement full audit trail per entity using history tables in PostgreSQL. Create triggers for INSERT/UPDATE/DELETE that record changes in *_history tables. Include user context via JSONB. Create efficient indexes on timestamps and entity ID. Support API endpoints to retrieve history. Use test containers and ensure all queries use parameterized statements. Secure API with JWT.",
  "tags": [
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Query Optimization",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "JSONB",
    "NULL Handling",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "REST API",
    "JWT Auth",
    "Pagination",
    "Sorting",
    "Filtering",
    "Validation",
    "Form Validation",
    "Rate Limiting",
    "Logging",
    "Headers",
    "Recovery",
    "HTTPS",
    "Reverse Proxy",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Slices",
    "Maps",
    "Interfaces",
    "Packages",
    "Imports",
    "Go Tools",
    "Context",
    "Make-New",
    "Defer"
  ]
},
{
  "id": 92,
  "name": "Feature Flag System (PostgreSQL)",
  "challenge": 12,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Create a system where application features can be toggled per user/group/role via PostgreSQL flags. Use JSONB for scope configuration. Use indexes on `user_id`, `flag`, and time ranges. Provide API endpoints to read flags and admin UI to toggle. Secure access via JWT, log changes in audit table, and rollback transactions if validation fails. Write integration tests with test containers.",
  "tags": [
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Query Optimization",
    "Parameterized Queries",
    "Transactions",
    "Migrations",
    "Seeding",
    "JSONB",
    "NULL Handling",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "REST API",
    "JWT Auth",
    "Session Auth",
    "Validation",
    "Form Validation",
    "Pagination",
    "Rate Limiting",
    "HTTPS",
    "Logging",
    "Middleware",
    "Headers",
    "Reverse Proxy",
    "Recovery",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Interfaces",
    "Packages",
    "Imports",
    "Make-New",
    "Defer",
    "Go Tools",
    "Context"
  ]
},
{
  "id": 93,
  "name": "Dynamic Report Builder (SQL Templates)",
  "challenge": 13,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Create an API that lets admins generate custom reports using dynamic SQL templates stored in the database. Inject filter values via parameterized queries. Prevent SQL injection using named placeholders. Use JSONB for filter metadata. Cache frequent queries and create views for heavy reports. Authenticate with JWT and test all variants using containerized PostgreSQL.",
  "tags": [
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Query Optimization",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "JSONB",
    "NULL Handling",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "Transactions",
    "REST API",
    "JWT Auth",
    "Filtering",
    "Sorting",
    "Pagination",
    "Rate Limiting",
    "Logging",
    "Recovery",
    "Validation",
    "Form Validation",
    "HTTPS",
    "Reverse Proxy",
    "Headers",
    "Session Auth",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Slices",
    "Interfaces",
    "Packages",
    "Imports",
    "Context",
    "Print-Scan",
    "Make-New",
    "Defer",
    "Go Tools"
  ]
},
{
  "id": 94,
  "name": "CRUD API with Soft Delete",
  "challenge": 14,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Build a full CRUD API with soft delete (status column + deleted_at). Record every delete/update in a JSONB audit column. Use transactions, indexing on deleted_at, and filtering by status. Implement pagination and sorting. Test audit integrity via test containers. Secure access via JWT, use parameterized queries, and limit privileges of DB users.",
  "tags": [
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Query Optimization",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "JSONB",
    "NULL Handling",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "REST API",
    "JWT Auth",
    "Session Auth",
    "Validation",
    "Form Validation",
    "Pagination",
    "Sorting",
    "Filtering",
    "Logging",
    "Recovery",
    "Rate Limiting",
    "HTTPS",
    "Reverse Proxy",
    "Headers",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Interfaces",
    "Packages",
    "Imports",
    "Go Tools",
    "Defer",
    "Make-New",
    "Context"
  ]
},
{
  "id": 95,
  "name": "Multi-Region PostgreSQL API",
  "challenge": 15,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Set up a Go API connected to a PostgreSQL database with multi-region replicas. Read from replicas and write to the primary. Use health checks to detect replica status. Ensure consistency via version numbers and retries. Implement test coverage via test containers. Restrict DB roles and optimize queries via prepared statements and indexes.",
  "tags": [
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Query Optimization",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "JSONB",
    "NULL Handling",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "REST API",
    "JWT Auth",
    "Validation",
    "Pagination",
    "Filtering",
    "Rate Limiting",
    "Logging",
    "Middleware",
    "Recovery",
    "Headers",
    "HTTPS",
    "Reverse Proxy",
    "Session Auth",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Packages",
    "Imports",
    "Context",
    "Defer",
    "Go Tools",
    "Make-New"
  ]
},
{
  "id": 96,
  "name": "Subscription Billing System",
  "challenge": 16,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Design a subscription billing backend with monthly invoicing and payment tracking. Use PostgreSQL for plans, subscriptions, invoices, and user billing history. Use transactions for atomic updates. Store pricing rules in JSONB. Add indexes for recurring billing cycles. Handle null values, seeding of test plans, and least privilege DB user. Add API endpoints for billing, retries, and webhooks.",
  "tags": [
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Query Optimization",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "JSONB",
    "NULL Handling",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "REST API",
    "JWT Auth",
    "Pagination",
    "Sorting",
    "Form Validation",
    "Validation",
    "Secure Password Hashing",
    "Logging",
    "Recovery",
    "Rate Limiting",
    "HTTPS",
    "Reverse Proxy",
    "Session Auth",
    "Email Verification",
    "Variables",
    "Structs",
    "Functions",
    "Pointers",
    "Slices",
    "Interfaces",
    "Maps",
    "Packages",
    "Imports",
    "Context",
    "Go Tools",
    "Defer",
    "Make-New"
  ]
},
{
  "id": 97,
  "name": "E-learning Progress Tracker",
  "challenge": 17,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Build a backend to track user progress in online courses. Use foreign keys for users, lessons, and progress. Include soft deletes, NULL support, JSONB for progress metadata. Use constraints and indexed timestamps. Wrap inserts/updates in transactions. Create role-limited DB user. Provide REST API and SSR HTML dashboard with filters and export options.",
  "tags": [
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "JSONB",
    "NULL Handling",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "Query Optimization",
    "REST API",
    "JWT Auth",
    "Session Auth",
    "Validation",
    "Pagination",
    "Filtering",
    "Sorting",
    "Static Assets",
    "HTML Templates",
    "Form Validation",
    "Logging",
    "Recovery",
    "HTTPS",
    "Reverse Proxy",
    "Variables",
    "Structs",
    "Pointers",
    "Functions",
    "Slices",
    "Interfaces",
    "Packages",
    "Imports",
    "Context",
    "Go Tools",
    "Print-Scan",
    "Make-New",
    "Defer"
  ]
},
{
  "id": 98,
  "name": "Document Management API",
  "challenge": 18,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Create a system to manage uploaded documents, where each update creates a new version. Use transactions to ensure atomicity of versioned writes. Index by `document_id`, `version`, and `user_id`. Store metadata and comments in JSONB. Create views for latest versions. Test with containers. Serve frontend HTML templates, and protect with auth middleware + rate limiting.",
  "tags": [
    "database/sql", "pgx/sqlx/sql drivers", "ORM (GORM, sqlx, bun)", "Transactions",
    "Query Optimization", "Parameterized Queries", "Migrations", "Seeding", "JSONB",
    "NULL Handling", "Indexing", "Test Containers", "Least Privilege DB User",

    "REST API", "JWT Auth", "Session Auth", "File Uploads", "Validation", "Pagination",
    "Filtering", "Sorting", "Rate Limiting", "Static Assets", "HTML Templates",
    "Recovery", "Logging", "HTTPS", "Reverse Proxy",

    "Variables", "Functions", "Pointers", "Structs", "Slices", "Maps", "Packages",
    "Imports", "Defer", "Go Tools", "Context"
  ]
}
,{
  "id": 99,
  "name": "Survey API (JSONB Answers + Aggregation)",
  "challenge": 19,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Create a survey system where users submit answers stored as JSONB. Include timestamp, user_id, and form_id. Aggregate results via PostgreSQL functions and views. Index the JSONB fields used for filtering. Use NULL handling, transactions, and test containers. Write endpoints for results export and analytics. Use rate-limited endpoints and secure roles.",
  "tags": [
    "database/sql", "pgx/sqlx/sql drivers", "ORM (GORM, sqlx, bun)", "Query Optimization",
    "Parameterized Queries", "Transactions", "Migrations", "Seeding", "JSONB",
    "NULL Handling", "Indexing", "Test Containers", "Least Privilege DB User",

    "REST API", "JWT Auth", "Form Validation", "Pagination", "Filtering", "Sorting",
    "Logging", "Recovery", "Rate Limiting", "Session Auth", "HTTPS", "Reverse Proxy",
    "Static Assets", "Headers",

    "Variables", "Functions", "Pointers", "Structs", "Packages", "Imports", "Go Tools",
    "Context", "Defer", "Make-New"
  ]
}
,{
  "id": 100,
  "name": "Enterprise API (Full PostgreSQL Power)",
  "challenge": 20,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Build a robust enterprise API with complex relations, access control, transactional workflows, advanced queries, JSONB, full audit, seeding, migrations, and test containers. Use PostgreSQL features like views, triggers, indexes, constraints, composite keys, enums, and foreign keys. Protect all access with JWT, enable role separation with DB grants, and prepare queries for speed. This is your master-level PostgreSQL Go API.",
  "tags": [
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Query Optimization",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "JSONB",
    "NULL Handling",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "REST API",
    "JWT Auth",
    "Session Auth",
    "Form Validation",
    "Pagination",
    "Filtering",
    "Sorting",
    "Rate Limiting",
    "Logging",
    "CORS",
    "HTTPS",
    "Reverse Proxy",
    "Static Assets",
    "HTML Templates",
    "Secure Password Hashing",
    "Email Verification",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Slices",
    "Maps",
    "Interfaces",
    "Packages",
    "Imports",
    "Context",
    "Defer",
    "Go Tools",
    "Make-New"
  ]
},{
  "id": 100,
  "name": "Enterprise API (Full PostgreSQL Power)",
  "challenge": 20,
  "level": 5,
  "completed": false,
  "published": false,
  "description": "Build a robust enterprise API with complex relations, access control, transactional workflows, advanced queries, JSONB, full audit, seeding, migrations, and test containers. Use PostgreSQL features like views, triggers, indexes, constraints, composite keys, enums, and foreign keys. Protect all access with JWT, enable role separation with DB grants, and prepare queries for speed. This is your master-level PostgreSQL Go API.",
  "tags": [
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Query Optimization",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "JSONB",
    "NULL Handling",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "REST API",
    "JWT Auth",
    "Session Auth",
    "Form Validation",
    "Pagination",
    "Filtering",
    "Sorting",
    "Rate Limiting",
    "Logging",
    "CORS",
    "HTTPS",
    "Reverse Proxy",
    "Static Assets",
    "HTML Templates",
    "Secure Password Hashing",
    "Email Verification",
    "Variables",
    "Functions",
    "Structs",
    "Pointers",
    "Slices",
    "Maps",
    "Interfaces",
    "Packages",
    "Imports",
    "Context",
    "Defer",
    "Go Tools",
    "Make-New"
  ]
},{
  "id": 101,
  "name": "Banking App (Clean Architecture + Events)",
  "challenge": 1,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Build a banking application where users can deposit, withdraw, and transfer funds. Apply Clean Architecture with domain-layer balance logic, service interfaces for transfer orchestration, and repositories for persistence. Use domain events for each transaction and store them. Apply CQRS for write/read separation. Secure endpoints with JWT. Use PostgreSQL with transactions and test containers.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "database/sql",
    "pgx/sqlx/sql drivers",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Parameterized Queries",
    "Indexing",
    "Test Containers",
    "Least Privilege DB User",
    "REST API",
    "JWT Auth",
    "Validation",
    "Pagination",
    "Rate Limiting",
    "Logging",
    "Recovery",
    "HTTPS",
    "Reverse Proxy",
    "Secure Password Hashing",
    "Variables",
    "Structs",
    "Pointers",
    "Functions",
    "Interfaces",
    "Packages",
    "Imports",
    "Go Tools",
    "Context",
    "Make-New",
    "Defer",
    "Generics"
  ]
},
{
  "id": 103,
  "name": "CMS Platform (Clean Admin/User Split)",
  "challenge": 3,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Create a modular content management system (CMS) with admin and user access. Separate layers for domain (content rules), services (publishing workflows), and persistence (PostgreSQL). Use SOLID interfaces for page service, media service, and tag service. Implement CQRS for content editing and viewing. Serve content via SSR templates and secure with middleware + JWT.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "Event Sourcing",
    "REST API",
    "JWT Auth",
    "Session Auth",
    "Validation",
    "Form Validation",
    "Pagination",
    "Filtering",
    "Sorting",
    "Static Assets",
    "HTML Templates",
    "File Uploads",
    "Secure Password Hashing",
    "Rate Limiting",
    "CORS",
    "Recovery",
    "HTTPS",
    "Reverse Proxy",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Migrations",
    "Seeding",
    "JSONB",
    "Transactions",
    "Indexing",
    "Test Containers",
    "Parameterized Queries",
    "Least Privilege DB User",
    "Variables",
    "Functions",
    "Pointers",
    "Slices",
    "Structs",
    "Interfaces",
    "Go Tools",
    "Context",
    "Packages",
    "Imports",
    "Defer",
    "Make-New"
  ]
}
,
{
  "id": 104,
  "name": "Booking System (CQRS + Events)",
  "challenge": 4,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Build a booking system (e.g., hotel/meeting rooms). Use Clean Architecture with command-side logic for booking/reservation, and read models for availability. Use PostgreSQL with separate schemas for read/write models. Event sourcing stores booking history. Apply CQRS, validate inputs, and isolate services. Write end-to-end tests using containerized DB + service layer mocks.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "REST API",
    "JWT Auth",
    "Validation",
    "Form Validation",
    "Pagination",
    "Rate Limiting",
    "Logging",
    "CORS",
    "Recovery",
    "HTTPS",
    "Reverse Proxy",
    "Session Auth",
    "Secure Password Hashing",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Parameterized Queries",
    "Seeding",
    "Indexing",
    "NULL Handling",
    "Test Containers",
    "JSONB",
    "Variables",
    "Functions",
    "Pointers",
    "Slices",
    "Interfaces",
    "Structs",
    "Context",
    "Packages",
    "Imports",
    "Go Tools",
    "Defer",
    "Make-New"
  ]
},
{
  "id": 105,
  "name": "SaaS Platform (Modular DDD)",
  "challenge": 5,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Design a SaaS platform using modular bounded contexts (e.g., billing, auth, usage, support). Apply Clean Architecture to each domain with interfaces, adapters, and orchestration via services. Use CQRS + Event Sourcing for decoupling. PostgreSQL is used with clear read/write separation. Secure every module with RBAC via middleware and build fully tested DDD units.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "REST API",
    "JWT Auth",
    "Session Auth",
    "Pagination",
    "Filtering",
    "Sorting",
    "Validation",
    "Form Validation",
    "File Uploads",
    "Secure Password Hashing",
    "Rate Limiting",
    "CORS",
    "Logging",
    "Recovery",
    "HTTPS",
    "Reverse Proxy",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Migrations",
    "Seeding",
    "Parameterized Queries",
    "Indexing",
    "Test Containers",
    "JSONB",
    "NULL Handling",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Interfaces",
    "Maps",
    "Slices",
    "Packages",
    "Imports",
    "Go Tools",
    "Context",
    "Defer",
    "Make-New"
  ]
},
{
  "id": 105,
  "name": "SaaS Platform (Modular DDD)",
  "challenge": 5,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Design a SaaS platform using modular bounded contexts (e.g., billing, auth, usage, support). Apply Clean Architecture to each domain with interfaces, adapters, and orchestration via services. Use CQRS + Event Sourcing for decoupling. PostgreSQL is used with clear read/write separation. Secure every module with RBAC via middleware and build fully tested DDD units.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "REST API",
    "JWT Auth",
    "Session Auth",
    "Pagination",
    "Filtering",
    "Sorting",
    "Validation",
    "Form Validation",
    "File Uploads",
    "Secure Password Hashing",
    "Rate Limiting",
    "CORS",
    "Logging",
    "Recovery",
    "HTTPS",
    "Reverse Proxy",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Migrations",
    "Seeding",
    "Parameterized Queries",
    "Indexing",
    "Test Containers",
    "JSONB",
    "NULL Handling",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Interfaces",
    "Maps",
    "Slices",
    "Packages",
    "Imports",
    "Go Tools",
    "Context",
    "Defer",
    "Make-New"
  ]
},
{
  "id": 106,
  "name": "HR Management Platform (Aggregates & Domain Modeling)",
  "challenge": 6,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Build an HR platform with employee records, leave requests, and performance logs. Use domain aggregates like Employee, Request, and Evaluation. Apply Clean Architecture, service interfaces, and repositories. Handle event publishing when a leave request is approved or denied. Use PostgreSQL with migrations, indexes, and JSONB metadata. Secure endpoints with RBAC and JWT.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "REST API",
    "JWT Auth",
    "Session Auth",
    "Validation",
    "Pagination",
    "Form Validation",
    "Rate Limiting",
    "Logging",
    "CORS",
    "HTTPS",
    "Reverse Proxy",
    "Secure Password Hashing",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Migrations",
    "Seeding",
    "Parameterized Queries",
    "Indexing",
    "Test Containers",
    "JSONB",
    "NULL Handling",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Slices",
    "Maps",
    "Interfaces",
    "Packages",
    "Imports",
    "Go Tools",
    "Context",
    "Defer",
    "Make-New"
  ]
},
{
  "id": 108,
  "name": "Multilingual Blog Engine (Modular DDD)",
  "challenge": 8,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Build a multilingual blog engine. Each language module is a bounded context with its own templates and content pipeline. Use Clean Architecture with separate packages for rendering, tagging, and publishing. Store content history via event sourcing. Implement CQRS for managing versions. Use PostgreSQL and serve public pages using Go HTML templates. JWT-protected admin panel included.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "REST API",
    "JWT Auth",
    "Validation",
    "Session Auth",
    "Pagination",
    "Form Validation",
    "Rate Limiting",
    "Secure Password Hashing",
    "Static Assets",
    "HTML Templates",
    "Logging",
    "CORS",
    "HTTPS",
    "Reverse Proxy",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Migrations",
    "Seeding",
    "Parameterized Queries",
    "Indexing",
    "JSONB",
    "Test Containers",
    "NULL Handling",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Interfaces",
    "Slices",
    "Packages",
    "Imports",
    "Go Tools",
    "Context",
    "Defer",
    "Make-New"
  ]
},
{
  "id": 109,
  "name": "IoT Device Collector (DDD + Aggregates)",
  "challenge": 9,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Develop a backend to collect data from IoT devices. Each device is an aggregate that records incoming measurements. Model device types, thresholds, and alerts as domain rules. Store data with JSONB, and apply event sourcing for lifecycle tracking. Use CQRS for ingest/query paths. PostgreSQL must use indexes and partitions. Handle high-frequency inserts with batching.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "REST API",
    "JWT Auth",
    "Validation",
    "Pagination",
    "Form Validation",
    "Rate Limiting",
    "Logging",
    "HTTPS",
    "Reverse Proxy",
    "CORS",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Parameterized Queries",
    "Migrations",
    "Indexing",
    "Seeding",
    "JSONB",
    "Test Containers",
    "NULL Handling",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Slices",
    "Maps",
    "Interfaces",
    "Packages",
    "Imports",
    "Go Tools",
    "Context",
    "Make-New",
    "Defer"
  ]
},
{
  "id": 110,
  "name": "Payment Gateway Adapter (Hexagonal Port/Adapter)",
  "challenge": 10,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Create a payment gateway integration layer using the Hexagonal Architecture pattern. Define ports (interfaces) for charging, refunding, and verifying payments. Implement adapters for Stripe and PayPal. Model Payment domain and transactions. Wrap DB interactions with repositories. Add a clean service orchestrator and test all use cases with mocks + container DB. Use CQRS for callbacks and status updates.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "REST API",
    "JWT Auth",
    "Validation",
    "Logging",
    "Form Validation",
    "Rate Limiting",
    "Recovery",
    "Pagination",
    "HTTPS",
    "Reverse Proxy",
    "CORS",
    "Session Auth",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Parameterized Queries",
    "Indexing",
    "Migrations",
    "Seeding",
    "JSONB",
    "Test Containers",
    "NULL Handling",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Interfaces",
    "Slices",
    "Maps",
    "Packages",
    "Imports",
    "Go Tools",
    "Context",
    "Defer",
    "Make-New"
  ]
},
{
  "id": 110,
  "name": "Payment Gateway Adapter (Hexagonal Port/Adapter)",
  "challenge": 10,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Create a payment gateway integration layer using the Hexagonal Architecture pattern. Define ports (interfaces) for charging, refunding, and verifying payments. Implement adapters for Stripe and PayPal. Model Payment domain and transactions. Wrap DB interactions with repositories. Add a clean service orchestrator and test all use cases with mocks + container DB. Use CQRS for callbacks and status updates.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "REST API",
    "JWT Auth",
    "Validation",
    "Logging",
    "Form Validation",
    "Rate Limiting",
    "Recovery",
    "Pagination",
    "HTTPS",
    "Reverse Proxy",
    "CORS",
    "Session Auth",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Parameterized Queries",
    "Indexing",
    "Migrations",
    "Seeding",
    "JSONB",
    "Test Containers",
    "NULL Handling",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Interfaces",
    "Slices",
    "Maps",
    "Packages",
    "Imports",
    "Go Tools",
    "Context",
    "Defer",
    "Make-New"
  ]
},
{
  "id": 112,
  "name": "Finance Ledger API (Value Objects)",
  "challenge": 12,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Design a finance API for ledger entries (income/expense). Model amounts, currencies, and operations as domain value objects. Use repository pattern for persistence. Apply service layer validation (overdraft prevention, rounding), and CQRS separation for monthly reports. JSONB used for storing tax details. Secure API with JWT, PostgreSQL indexes and test containers for e2e testing.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "REST API",
    "JWT Auth",
    "Session Auth",
    "Validation",
    "Pagination",
    "Sorting",
    "Form Validation",
    "Logging",
    "Rate Limiting",
    "HTTPS",
    "Reverse Proxy",
    "CORS",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Parameterized Queries",
    "Migrations",
    "Indexing",
    "JSONB",
    "NULL Handling",
    "Test Containers",
    "Seeding",
    "Variables",
    "Structs",
    "Interfaces",
    "Pointers",
    "Functions",
    "Slices",
    "Packages",
    "Imports",
    "Go Tools",
    "Context",
    "Defer",
    "Make-New"
  ]
},
{
  "id": 113,
  "name": "Forum App (Modular Aggregates)",
  "challenge": 13,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Build a forum platform using modular DDD aggregates (Thread, Post, Vote, User). Apply Clean Architecture with repository patterns per module. CQRS is used for write (post, vote) and read (threads, rankings). Use PostgreSQL transactions and constraints. Apply rate limiting and RBAC security. Fully tested with Go service layer and DB mocks.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "REST API",
    "JWT Auth",
    "Session Auth",
    "Validation",
    "Pagination",
    "Filtering",
    "Sorting",
    "Rate Limiting",
    "Form Validation",
    "Logging",
    "Recovery",
    "CORS",
    "HTTPS",
    "Reverse Proxy",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "Indexing",
    "NULL Handling",
    "Test Containers",
    "JSONB",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Interfaces",
    "Maps",
    "Slices",
    "Packages",
    "Imports",
    "Context",
    "Go Tools",
    "Make-New",
    "Defer"
  ]
},
{
  "id": 114,
  "name": "User Notification Service (Domain Filters)",
  "challenge": 14,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Design a backend to manage user notifications with domain rules: preferences, frequency, channel (email, sms). Use aggregates like Notification and Preference. CQRS to send, queue, and retrieve notifications. Store user rules in JSONB. Event sourcing stores delivery attempts. PostgreSQL for persistence, secure JWT endpoints, rate limits and full testing using mocks and test containers.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "REST API",
    "JWT Auth",
    "Validation",
    "Session Auth",
    "Form Validation",
    "Rate Limiting",
    "Logging",
    "HTTPS",
    "Reverse Proxy",
    "CORS",
    "Pagination",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Parameterized Queries",
    "Migrations",
    "Indexing",
    "JSONB",
    "Seeding",
    "NULL Handling",
    "Test Containers",
    "Variables",
    "Structs",
    "Pointers",
    "Functions",
    "Interfaces",
    "Slices",
    "Maps",
    "Packages",
    "Imports",
    "Context",
    "Go Tools",
    "Defer",
    "Make-New"
  ]
},
{
  "id": 115,
  "name": "Knowledge Base System (Hierarchical Domains)",
  "challenge": 15,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Develop a documentation knowledge base using Clean Architecture. Use domain entities like Topic, Article, Category. Implement domain-level search filters and tag logic. CQRS for edit vs read. Use PostgreSQL fulltext indexing, JSONB for metadata, and versioning for audit logs. Secure via RBAC and JWT. Fully containerized tests.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "REST API",
    "JWT Auth",
    "Validation",
    "Pagination",
    "Filtering",
    "Sorting",
    "Form Validation",
    "Session Auth",
    "Rate Limiting",
    "Logging",
    "HTTPS",
    "Reverse Proxy",
    "Static Assets",
    "HTML Templates",
    "CORS",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Migrations",
    "Parameterized Queries",
    "Indexing",
    "JSONB",
    "Test Containers",
    "NULL Handling",
    "Seeding",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Interfaces",
    "Slices",
    "Maps",
    "Packages",
    "Imports",
    "Context",
    "Go Tools",
    "Make-New",
    "Defer"
  ]
},
{
  "id": 116,
  "name": "Job Marketplace API (Role-Based Aggregates)",
  "challenge": 16,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Build a backend for a job platform with two main roles: employer and applicant. Use aggregates like JobPost, Application, Profile. Apply Clean Architecture with repositories and service layers. Separate bounded contexts by role. Use CQRS for job CRUD vs listing. PostgreSQL stores JSONB metadata and audit logs. Secure with JWT, RBAC, and write full tests with mocks and containers.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "REST API",
    "JWT Auth",
    "Session Auth",
    "Form Validation",
    "Pagination",
    "Filtering",
    "Sorting",
    "Logging",
    "Rate Limiting",
    "Recovery",
    "HTTPS",
    "Reverse Proxy",
    "CORS",
    "Secure Password Hashing",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "Indexing",
    "JSONB",
    "Test Containers",
    "NULL Handling",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Interfaces",
    "Packages",
    "Imports",
    "Context",
    "Go Tools",
    "Make-New",
    "Defer"
  ]
},
{
  "id": 117,
  "name": "SaaS Subscription API (Bounded Contexts)",
  "challenge": 17,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Design a scalable SaaS backend split into bounded contexts: users, plans, payments, analytics. Each domain module follows Clean Architecture. Apply event sourcing for subscription lifecycle. Use PostgreSQL with JSONB billing metadata and CQRS for analytics separation. Implement RBAC middleware and cover with test containers and mocks.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "REST API",
    "JWT Auth",
    "Session Auth",
    "Pagination",
    "Sorting",
    "Validation",
    "Form Validation",
    "Secure Password Hashing",
    "Rate Limiting",
    "Logging",
    "HTTPS",
    "Reverse Proxy",
    "CORS",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "Indexing",
    "JSONB",
    "Test Containers",
    "NULL Handling",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Interfaces",
    "Packages",
    "Imports",
    "Context",
    "Go Tools",
    "Defer",
    "Make-New"
  ]
},
{
  "id": 118,
  "name": "Checkout Engine (DDD + Orchestration)",
  "challenge": 18,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Create a checkout engine with orchestrated domain services: cart → payment → stock update → receipt. Use value objects for pricing, services for checkout steps, and aggregates for Cart, Order, Payment. Apply Clean Architecture with strong decoupling. Handle event logs and store them in PostgreSQL JSONB. Full coverage with DB mocks and container-based tests.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "REST API",
    "JWT Auth",
    "Validation",
    "Form Validation",
    "Pagination",
    "Sorting",
    "Filtering",
    "Logging",
    "HTTPS",
    "Reverse Proxy",
    "CORS",
    "Session Auth",
    "Secure Password Hashing",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "Indexing",
    "JSONB",
    "NULL Handling",
    "Test Containers",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Interfaces",
    "Packages",
    "Imports",
    "Context",
    "Go Tools",
    "Defer",
    "Make-New"
  ]
},
{
  "id": 119,
  "name": "Audit Log Sidecar (Clean Adapter)",
  "challenge": 19,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Create an independent audit logging sidecar using Clean Architecture. The sidecar listens to events from other services and logs them to PostgreSQL. It implements domain modeling for LogEntry. Repositories store logs with full indexing and JSONB context. CQRS separates logging commands from report queries. Build the service to be reusable across apps.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "REST API",
    "JWT Auth",
    "Logging",
    "Pagination",
    "Filtering",
    "Sorting",
    "Validation",
    "HTTPS",
    "CORS",
    "Reverse Proxy",
    "Rate Limiting",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "Indexing",
    "JSONB",
    "NULL Handling",
    "Test Containers",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Interfaces",
    "Packages",
    "Imports",
    "Context",
    "Go Tools",
    "Defer",
    "Make-New"
  ]
},
{
  "id": 120,
  "name": "Multi-Tenant Clean SaaS",
  "challenge": 20,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Build a scalable multi-tenant SaaS system using Clean Architecture. Isolate tenant data at DB and domain level. Apply CQRS and domain services to manage tenant onboarding, billing, and user scopes. Use PostgreSQL schemas or tenant IDs. JSONB stores custom configurations. Authenticate via JWT, enforce RBAC, and test modules in isolation with containerized environments.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "REST API",
    "JWT Auth",
    "RBAC",
    "Session Auth",
    "Pagination",
    "Filtering",
    "Validation",
    "Secure Password Hashing",
    "Rate Limiting",
    "Logging",
    "HTTPS",
    "CORS",
    "Reverse Proxy",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "Indexing",
    "JSONB",
    "NULL Handling",
    "Test Containers",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Interfaces",
    "Packages",
    "Imports",
    "Go Tools",
    "Context",
    "Defer",
    "Make-New"
  ]
},
{
  "id": 120,
  "name": "Multi-Tenant Clean SaaS",
  "challenge": 20,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Build a scalable multi-tenant SaaS system using Clean Architecture. Isolate tenant data at DB and domain level. Apply CQRS and domain services to manage tenant onboarding, billing, and user scopes. Use PostgreSQL schemas or tenant IDs. JSONB stores custom configurations. Authenticate via JWT, enforce RBAC, and test modules in isolation with containerized environments.",
  "tags": [
    "MVC", "Layered Architecture", "Clean Architecture", "SOLID", "CQRS", "Event Sourcing",
    "Repository Pattern", "Service Interfaces", "Domain Modeling",

    "REST API", "JWT Auth", "RBAC", "Session Auth", "Pagination", "Filtering", "Validation",
    "Secure Password Hashing", "Rate Limiting", "Logging", "HTTPS", "CORS", "Reverse Proxy",

    "database/sql", "ORM (GORM, sqlx, bun)", "Transactions", "Parameterized Queries", "Migrations",
    "Seeding", "Indexing", "JSONB", "NULL Handling", "Test Containers",

    "Variables", "Functions", "Pointers", "Structs", "Interfaces", "Packages", "Imports",
    "Go Tools", "Context", "Defer", "Make-New"
  ]
}
,{
  "id": 120,
  "name": "Multi-Tenant Clean SaaS",
  "challenge": 20,
  "level": 6,
  "completed": false,
  "published": false,
  "description": "Build a scalable multi-tenant SaaS system using Clean Architecture. Isolate tenant data at DB and domain level. Apply CQRS and domain services to manage tenant onboarding, billing, and user scopes. Use PostgreSQL schemas or tenant IDs. JSONB stores custom configurations. Authenticate via JWT, enforce RBAC, and test modules in isolation with containerized environments.",
  "tags": [
    "MVC",
    "Layered Architecture",
    "Clean Architecture",
    "SOLID",
    "CQRS",
    "Event Sourcing",
    "Repository Pattern",
    "Service Interfaces",
    "Domain Modeling",
    "REST API",
    "JWT Auth",
    "RBAC",
    "Session Auth",
    "Pagination",
    "Filtering",
    "Validation",
    "Secure Password Hashing",
    "Rate Limiting",
    "Logging",
    "HTTPS",
    "CORS",
    "Reverse Proxy",
    "database/sql",
    "ORM (GORM, sqlx, bun)",
    "Transactions",
    "Parameterized Queries",
    "Migrations",
    "Seeding",
    "Indexing",
    "JSONB",
    "NULL Handling",
    "Test Containers",
    "Variables",
    "Functions",
    "Pointers",
    "Structs",
    "Interfaces",
    "Packages",
    "Imports",
    "Go Tools",
    "Context",
    "Defer",
    "Make-New"
  ]
},
{
  "id": 122,
  "name": "Inventory Service (Choreography + Retry)",
  "challenge": 2,
  "level": 7,
  "completed": false,
  "published": false,
  "description": "Create an inventory microservice that listens to Kafka/NATS topics for new orders. Adjust stock and emit success/failure events. Use retry patterns with exponential backoff. Add circuit breaker for DB access. Use Jaeger for tracing and Consul for discovery. All interactions must be idempotent and contract-tested via protobuf.",
  "tags": [
    "Microservice Architecture in Go",
    "gRPC with Protobuf",
    "Protobuf Code Gen & Contract Testing",
    "Async Messaging (Kafka, NATS, RabbitMQ)",
    "Sagas & Event Choreography",
    "Service Discovery (Consul / etcd)",
    "Circuit Breakers (resilience4go)",
    "Retry Patterns",
    "Distributed Tracing (OpenTelemetry, Jaeger)",
    "Idempotent APIs",
    "API Gateways (Kong, Traefik)",
    "Transactions",
    "Logging",
    "ORM (sqlx)",
    "Packages",
    "Imports",
    "Structs",
    "Interfaces",
    "Functions",
    "Pointers",
    "Go Tools",
    "Context",
    "Make-New",
    "Defer"
  ]
},
{
  "id": 123,
  "name": "Auth Service (gRPC + JWT + Tracing)",
  "challenge": 3,
  "level": 7,
  "completed": false,
  "published": false,
  "description": "Build an authentication microservice that exposes gRPC APIs for signup, login, and token verification. Use protobuf contracts, implement contract tests. JWT generation must be idempotent. Register the service via Consul. Use OpenTelemetry to trace authentication latency. Secure behind Kong gateway and expose metrics.",
  "tags": [
    "Microservice Architecture in Go",
    "gRPC with Protobuf",
    "Protobuf Code Gen & Contract Testing",
    "Service Discovery (Consul / etcd)",
    "Circuit Breakers (resilience4go)",
    "Distributed Tracing (OpenTelemetry, Jaeger)",
    "Idempotent APIs",
    "API Gateways (Kong, Traefik)",
    "Retry Patterns",
    "Sagas & Event Choreography",
    "Async Messaging (Kafka, NATS, RabbitMQ)",
    "JWT Auth",
    "Validation",
    "Secure Password Hashing",
    "Logging",
    "Recovery",
    "Packages",
    "Context",
    "Go Tools",
    "Imports",
    "Functions",
    "Structs",
    "Interfaces"
  ]
},
{
  "id": 124,
  "name": "Payment Processor (NATS + Circuit Breaker)",
  "challenge": 4,
  "level": 7,
  "completed": false,
  "published": false,
  "description": "Implement a payment consumer service that subscribes to NATS events from order service. Handle payments with external gateway (simulate Stripe). Use circuit breaker when gateway fails and retries on timeout. Record every payment attempt in PostgreSQL. Use protobuf schemas and OpenTelemetry for tracing. Deploy via Kong gateway.",
  "tags": [
    "Microservice Architecture in Go",
    "gRPC with Protobuf",
    "Protobuf Code Gen & Contract Testing",
    "Async Messaging (Kafka, NATS, RabbitMQ)",
    "Sagas & Event Choreography",
    "Service Discovery (Consul / etcd)",
    "Circuit Breakers (resilience4go)",
    "Retry Patterns",
    "Distributed Tracing (OpenTelemetry, Jaeger)",
    "Idempotent APIs",
    "API Gateways (Kong, Traefik)",
    "JWT Auth",
    "Transactions",
    "Validation",
    "Logging",
    "HTTPS",
    "Reverse Proxy",
    "Packages",
    "Imports",
    "Functions",
    "Context",
    "Interfaces",
    "Structs"
  ]
},
{
  "id": 125,
  "name": "API Gateway Integration (Kong + gRPC)",
  "challenge": 5,
  "level": 7,
  "completed": false,
  "published": false,
  "description": "Set up a centralized API Gateway using Kong. Route all gRPC and REST calls to underlying microservices (auth, orders, inventory, payments). Apply rate limiting, JWT validation, and header injection. Configure Kong with service discovery via Consul. Add tracing headers and logging. Test with contract-based gRPC mocking.",
  "tags": [
    "Microservice Architecture in Go",
    "gRPC with Protobuf",
    "Protobuf Code Gen & Contract Testing",
    "Async Messaging (Kafka, NATS, RabbitMQ)",
    "Sagas & Event Choreography",
    "Service Discovery (Consul / etcd)",
    "Circuit Breakers (resilience4go)",
    "Retry Patterns",
    "Distributed Tracing (OpenTelemetry, Jaeger)",
    "Idempotent APIs",
    "API Gateways (Kong, Traefik)",
    "Logging",
    "JWT Auth",
    "Headers",
    "CORS",
    "Rate Limiting",
    "Packages",
    "Imports",
    "Structs",
    "Go Tools",
    "Context",
    "Interfaces",
    "Defer",
    "Make-New"
  ]
},
{
  "id": 126,
  "name": "Email Queue Processor (NATS + Retry Logic)",
  "challenge": 6,
  "level": 7,
  "completed": false,
  "published": false,
  "description": "Develop an email delivery microservice that subscribes to a NATS queue. Each message contains a gRPC contract-defined payload with email content. Apply retry policies with exponential backoff. Implement distributed tracing using OpenTelemetry, register the service in etcd, and protect it behind Kong. Handle idempotency and add circuit breakers to the email provider integration.",
  "tags": [
    "Microservice Architecture in Go",
    "gRPC with Protobuf",
    "Protobuf Code Gen & Contract Testing",
    "Async Messaging (Kafka, NATS, RabbitMQ)",
    "Retry Patterns",
    "Circuit Breakers (resilience4go)",
    "Service Discovery (Consul / etcd)",
    "Sagas & Event Choreography",
    "Distributed Tracing (OpenTelemetry, Jaeger)",
    "Idempotent APIs",
    "API Gateways (Kong, Traefik)",
    "Logging",
    "Validation",
    "Packages",
    "Interfaces",
    "Structs",
    "Go Tools",
    "Context"
  ]
},
{
  "id": 127,
  "name": "Payments Aggregator (gRPC Fan-In)",
  "challenge": 7,
  "level": 7,
  "completed": false,
  "published": false,
  "description": "Create a payment aggregation service that collects payment confirmations from Stripe, PayPal, and internal services via gRPC. Use fan-in pattern to unify inputs into a single ledger. Wrap calls with circuit breakers and trace all requests. Use protobuf for contract safety and register with Consul. Protect the service behind Kong Gateway and make every transaction idempotent.",
  "tags": [
    "Microservice Architecture in Go",
    "gRPC with Protobuf",
    "Protobuf Code Gen & Contract Testing",
    "Async Messaging (Kafka, NATS, RabbitMQ)",
    "Sagas & Event Choreography",
    "Service Discovery (Consul / etcd)",
    "Circuit Breakers (resilience4go)",
    "Retry Patterns",
    "Distributed Tracing (OpenTelemetry, Jaeger)",
    "Idempotent APIs",
    "API Gateways (Kong, Traefik)",
    "Logging",
    "HTTPS",
    "Validation",
    "Structs",
    "Functions",
    "Packages",
    "Context",
    "Go Tools"
  ]
},
{
  "id": 128,
  "name": "Analytics Collector (Tracing Fan-Out)",
  "challenge": 8,
  "level": 7,
  "completed": false,
  "published": false,
  "description": "Build an analytics collector service that receives events over gRPC and asynchronously dispatches them to Elasticsearch, PostgreSQL, and BigQuery workers. Use fan-out pattern with Kafka/NATS. All operations must be traced with OpenTelemetry. Expose a contract-validated gRPC interface and protect it with Kong. Ensure fault tolerance with retries and fallback handlers.",
  "tags": [
    "Microservice Architecture in Go", "gRPC with Protobuf", "Protobuf Code Gen & Contract Testing",
    "Async Messaging (Kafka, NATS, RabbitMQ)", "Sagas & Event Choreography",
    "Service Discovery (Consul / etcd)", "Retry Patterns", "Circuit Breakers (resilience4go)",
    "Distributed Tracing (OpenTelemetry, Jaeger)", "Idempotent APIs", "API Gateways (Kong, Traefik)",

    "Logging", "Pagination", "Packages", "Structs", "Functions", "Context", "Go Tools"
  ]
}

,
{
  "id": 129,
  "name": "Central Rate Limiter Service",
  "challenge": 9,
  "level": 7,
  "completed": false,
  "published": false,
  "description": "Develop a rate-limiting service consumed by Kong via gRPC. All services request limit validation before proceeding. Use gRPC contract validation, expose metrics with OpenTelemetry, and distribute rate windows via messaging. Use retries and circuit breakers to tolerate outages. Register the service with etcd and ensure it handles concurrent requests correctly.",
  "tags": [
    "Microservice Architecture in Go",
    "gRPC with Protobuf",
    "Protobuf Code Gen & Contract Testing",
    "Async Messaging (Kafka, NATS, RabbitMQ)",
    "Service Discovery (Consul / etcd)",
    "Retry Patterns",
    "Circuit Breakers (resilience4go)",
    "Distributed Tracing (OpenTelemetry, Jaeger)",
    "Idempotent APIs",
    "API Gateways (Kong, Traefik)",
    "Sagas & Event Choreography",
    "Logging",
    "Packages",
    "Interfaces",
    "Context",
    "Go Tools",
    "Structs",
    "Functions"
  ]
}
,
{
  "id": 130,
  "name": "Product Recommender (Event-Driven)",
  "challenge": 10,
  "level": 7,
  "completed": false,
  "published": false,
  "description": "Design a product recommendation service that reacts to user behavior events. Rebuild recommendations asynchronously when 'user_interaction' events arrive via Kafka. Expose gRPC API for querying recommendations. Ensure circuit breaker protection, idempotency, and full OpenTelemetry traces. Route requests through Traefik and register for discovery in Consul.",
  "tags": [
    "Microservice Architecture in Go",
    "gRPC with Protobuf",
    "Protobuf Code Gen & Contract Testing",
    "Async Messaging (Kafka, NATS, RabbitMQ)",
    "Sagas & Event Choreography",
    "Service Discovery (Consul / etcd)",
    "Retry Patterns",
    "Circuit Breakers (resilience4go)",
    "Distributed Tracing (OpenTelemetry, Jaeger)",
    "Idempotent APIs",
    "API Gateways (Kong, Traefik)",
    "Logging",
    "Functions",
    "Context",
    "Packages",
    "Go Tools",
    "Imports",
    "Structs"
  ]
},
{
  "id": 131,
  "name": "Geo-Distributed Service (Load-Aware Discovery)",
  "challenge": 11,
  "level": 7,
  "completed": false,
  "published": false,
  "description": "Create a service that registers with Consul using custom tags for its location and load. Clients query services closest to them with least current usage. Ensure all calls go through Traefik, with OpenTelemetry spans tracking hops. Use Protobuf/gRPC for contract-safe communication, and fallback to backup region via circuit breaker if the local instance is down.",
  "tags": [
    "Microservice Architecture in Go",
    "gRPC with Protobuf",
    "Protobuf Code Gen & Contract Testing",
    "Service Discovery (Consul / etcd)",
    "Circuit Breakers (resilience4go)",
    "API Gateways (Kong, Traefik)",
    "Retry Patterns",
    "Distributed Tracing (OpenTelemetry, Jaeger)",
    "Idempotent APIs",
    "Async Messaging (Kafka, NATS, RabbitMQ)",
    "Sagas & Event Choreography",
    "Logging",
    "HTTPS",
    "Context",
    "Structs",
    "Interfaces",
    "Packages",
    "Go Tools"
  ]
},
{
  "id": 132,
  "name": "Transaction Coordinator (Saga Pattern)",
  "challenge": 12,
  "level": 7,
  "completed": false,
  "published": false,
  "description": "Build a transaction coordinator that manages multi-step distributed operations (e.g., flight + hotel booking). Each step is a gRPC call to an external microservice. Implement saga orchestration with rollback logic. Store the saga state in PostgreSQL. Use OpenTelemetry for distributed tracing and register all services in Consul. All interactions are idempotent and retryable.",
  "tags": [
    "Microservice Architecture in Go",
    "gRPC with Protobuf",
    "Protobuf Code Gen & Contract Testing",
    "Sagas & Event Choreography",
    "Service Discovery (Consul / etcd)",
    "Circuit Breakers (resilience4go)",
    "Retry Patterns",
    "Distributed Tracing (OpenTelemetry, Jaeger)",
    "Idempotent APIs",
    "API Gateways (Kong, Traefik)",
    "Async Messaging (Kafka, NATS, RabbitMQ)",
    "Transactions",
    "ORM",
    "Packages",
    "Functions",
    "Pointers",
    "Interfaces",
    "Go Tools",
    "Context"
  ]
},
{
  "id": 133,
  "name": "Stock Market Event Ingestion (Backpressure)",
  "challenge": 13,
  "level": 7,
  "completed": false,
  "published": false,
  "description": "Design a system that ingests real-time stock market events via NATS and pushes them to storage + analytics microservices. Use buffering and backpressure techniques to prevent overload. Fan-out logic routes data to multiple consumers. Trace events with OpenTelemetry and retry failed events. Each part communicates via gRPC, behind Kong Gateway, and registered via etcd.",
  "tags": [
    "Microservice Architecture in Go",
    "gRPC with Protobuf",
    "Protobuf Code Gen & Contract Testing",
    "Async Messaging (Kafka, NATS, RabbitMQ)",
    "Service Discovery (Consul / etcd)",
    "Circuit Breakers (resilience4go)",
    "Retry Patterns",
    "Distributed Tracing (OpenTelemetry, Jaeger)",
    "Idempotent APIs",
    "Sagas & Event Choreography",
    "API Gateways (Kong, Traefik)",
    "Logging",
    "Packages",
    "Go Tools",
    "Structs",
    "Pointers",
    "Functions",
    "Context"
  ]
},
{
  "id": 134,
  "name": "Invoice Service (Idempotent Kafka Dedup)",
  "challenge": 14,
  "level": 7,
  "completed": false,
  "published": false,
  "description": "Implement an invoice generation microservice that receives order completion events from Kafka. Use Kafka message keys and Redis to detect duplicates and guarantee idempotency. Expose endpoints via gRPC through Kong. Apply circuit breakers for downstream invoice PDF generation service. Add full OpenTelemetry traces and service discovery.",
  "tags": [
    "Microservice Architecture in Go", "gRPC with Protobuf", "Protobuf Code Gen & Contract Testing",
    "Async Messaging (Kafka, NATS, RabbitMQ)", "Idempotent APIs", "Service Discovery (Consul / etcd)",
    "Circuit Breakers (resilience4go)", "Retry Patterns", "Distributed Tracing (OpenTelemetry, Jaeger)",
    "API Gateways (Kong, Traefik)", "Sagas & Event Choreography",

    "Logging", "Packages", "Context", "Interfaces", "Go Tools", "Structs", "Pointers"
  ]
},
{
  "id": 135,
  "name": "Distributed Health Mesh (gRPC + Tracing)",
  "challenge": 15,
  "level": 7,
  "completed": false,
  "published": false,
  "description": "Build a health mesh where each service exposes a gRPC health-check endpoint. A central mesh service queries every registered microservice via gRPC and exposes status via a dashboard. Each health call is traced via OpenTelemetry. Retry and circuit breaker patterns prevent overloads. Kong handles all routing and Consul registers all services.",
  "tags": [
    "Microservice Architecture in Go",
    "gRPC with Protobuf",
    "Protobuf Code Gen & Contract Testing",
    "Service Discovery (Consul / etcd)",
    "Distributed Tracing (OpenTelemetry, Jaeger)",
    "Retry Patterns",
    "Circuit Breakers (resilience4go)",
    "API Gateways (Kong, Traefik)",
    "Idempotent APIs",
    "Async Messaging (Kafka, NATS, RabbitMQ)",
    "Sagas & Event Choreography",
    "Logging",
    "Monitoring",
    "Functions",
    "Interfaces",
    "Packages",
    "Go Tools",
    "Context"
  ]
},
{
  "id": 136,
  "name": "Real-Time Chat System (NATS Streaming)",
  "challenge": 16,
  "level": 7,
  "completed": false,
  "published": false,
  "description": "Create a distributed real-time chat system using NATS Streaming. Each chat room is a topic. Clients subscribe via gRPC stream endpoints. Ensure delivery guarantees and message order. All events must be traced with OpenTelemetry. Handle spikes with backpressure, expose metrics, and route traffic through Traefik. Implement circuit breakers for connection losses.",
  "tags": [
    "Microservice Architecture in Go",
    "gRPC with Protobuf",
    "Protobuf Code Gen & Contract Testing",
    "Async Messaging (Kafka, NATS, RabbitMQ)",
    "Sagas & Event Choreography",
    "Service Discovery (Consul / etcd)",
    "Circuit Breakers (resilience4go)",
    "Retry Patterns",
    "Distributed Tracing (OpenTelemetry, Jaeger)",
    "Idempotent APIs",
    "API Gateways (Kong, Traefik)",
    "Logging",
    "Interfaces",
    "Packages",
    "Structs",
    "Pointers",
    "Functions",
    "Go Tools",
    "Context"
  ]
},
{
  "id": 138,
  "name": "Multi-Region Sync API (Reconciliation + Messaging)",
  "challenge": 18,
  "level": 7,
  "completed": false,
  "published": false,
  "description": "Develop a syncing system between two regions where updates are replicated via messaging. Use a Kafka topic for cross-region propagation. Detect conflicts via message timestamps and reconcile them using rules. Protect sync logic with circuit breakers and expose traceable gRPC endpoints. Register regions with Consul and route through Kong Gateway.",
  "tags": [
    "Microservice Architecture in Go",
    "gRPC with Protobuf",
    "Protobuf Code Gen & Contract Testing",
    "Async Messaging (Kafka, NATS, RabbitMQ)",
    "Retry Patterns",
    "Circuit Breakers (resilience4go)",
    "Distributed Tracing (OpenTelemetry, Jaeger)",
    "Service Discovery (Consul / etcd)",
    "Idempotent APIs",
    "API Gateways (Kong, Traefik)",
    "Sagas & Event Choreography",
    "Logging",
    "Packages",
    "Pointers",
    "Structs",
    "Interfaces",
    "Context",
    "Go Tools"
  ]
},
{
  "id": 139,
  "name": "IoT Metrics Collector (gRPC Streaming)",
  "challenge": 19,
  "level": 7,
  "completed": false,
  "published": false,
  "description": "Collect streaming sensor data from thousands of IoT devices via gRPC bidirectional streams. Buffer inputs, apply retry and drop policies, and trace ingestion flow with OpenTelemetry. Forward batched readings via Kafka to downstream processors. Discover endpoints via Consul and expose gRPC services behind Traefik Gateway. All streams are contract-tested.",
  "tags": [
    "Microservice Architecture in Go",
    "gRPC with Protobuf",
    "Protobuf Code Gen & Contract Testing",
    "Async Messaging (Kafka, NATS, RabbitMQ)",
    "Retry Patterns",
    "Service Discovery (Consul / etcd)",
    "Circuit Breakers (resilience4go)",
    "Distributed Tracing (OpenTelemetry, Jaeger)",
    "API Gateways (Kong, Traefik)",
    "Sagas & Event Choreography",
    "Idempotent APIs",
    "Logging",
    "Functions",
    "Structs",
    "Interfaces",
    "Packages",
    "Context",
    "Go Tools"
  ]
},
{
  "id": 140,
  "name": "Global API Router (gRPC Gateway + Central Logic)",
  "challenge": 20,
  "level": 7,
  "completed": false,
  "published": false,
  "description": "Build a global gateway router that dynamically maps service names to gRPC endpoints using Consul tags. The router acts as an API gateway routing layer and applies auth, tracing, circuit breakers, and retry strategies. All interactions use Protobuf contracts. The router emits OpenTelemetry data and includes fallback routing in case of failure. Fully stateless and highly available.",
  "tags": [
    "Microservice Architecture in Go",
    "gRPC with Protobuf",
    "Protobuf Code Gen & Contract Testing",
    "API Gateways (Kong, Traefik)",
    "Service Discovery (Consul / etcd)",
    "Retry Patterns",
    "Circuit Breakers (resilience4go)",
    "Distributed Tracing (OpenTelemetry, Jaeger)",
    "Idempotent APIs",
    "Sagas & Event Choreography",
    "Async Messaging (Kafka, NATS, RabbitMQ)",
    "Logging",
    "HTTPS",
    "Packages",
    "Structs",
    "Interfaces",
    "Context",
    "Go Tools"
  ]
},
{
  "id": 141,
  "name": "Hardened REST API (Production-Ready)",
  "challenge": 1,
  "level": 8,
  "completed": false,
  "published": false,
  "description": "Build a secure REST API with CSRF and CORS protections, secure cookie-based session tokens, hidden server headers, strict Content-Type checks, TLS configuration (Let's Encrypt or self-signed), and rate-limiting with Redis. Add brute force prevention, rotating refresh tokens, validation middleware, and log sanitization. Run automated penetration tests (e.g., OWASP ZAP). Ensure GDPR cookie banner + opt-in.",
  "tags": [
    "CORS & CSRF",
    "XSS Prevention",
    "Secure Token Storage",
    "Secrets Management",
    "TLS Certs",
    "Brute Force Protection",
    "Request Validation",
    "API Abuse Protection",
    "Hidden Server Headers",
    "Secure Headers",
    "Content-Type Enforcement",
    "Rate Limiting",
    "Token Rotation",
    "Penetration Testing Tools",
    "GDPR & Cookie Compliance",
    "REST API",
    "JWT Auth",
    "Session Auth",
    "Logging",
    "Pagination",
    "Validation",
    "Reverse Proxy",
    "HTTPS",
    "Recovery",
    "Packages",
    "Imports",
    "Go Tools",
    "Structs",
    "Functions",
    "Context",
    "Make-New"
  ]
},
{
  "id": 142,
  "name": "OAuth2 Login + Audit System",
  "challenge": 2,
  "level": 8,
  "completed": false,
  "published": false,
  "description": "Create a secure OAuth2 login system (Google, GitHub). Protect against CSRF with state verification. Store tokens securely in HTTP-only, same-site cookies. Log each auth attempt and audit failed logins. Add brute-force protection and rate-limiting. Validate all inputs and block suspicious user-agents. Include GDPR-friendly cookie management and content security policies.",
  "tags": [
    "CORS & CSRF",
    "XSS Prevention",
    "Secure Token Storage",
    "Secrets Management",
    "TLS Certs",
    "Brute Force Protection",
    "Request Validation",
    "API Abuse Protection",
    "Hidden Server Headers",
    "Secure Headers",
    "Content-Type Enforcement",
    "Rate Limiting",
    "Token Rotation",
    "Penetration Testing Tools",
    "GDPR & Cookie Compliance",
    "OAuth2 Login",
    "Session Auth",
    "JWT Auth",
    "Validation",
    "Logging",
    "HTTPS",
    "Reverse Proxy",
    "Structs",
    "Interfaces",
    "Packages",
    "Imports",
    "Context",
    "Go Tools"
  ]
},
{
  "id": 143,
  "name": "Secrets Manager (Vault + RBAC)",
  "challenge": 3,
  "level": 8,
  "completed": false,
  "published": false,
  "description": "Build a service to manage encrypted secrets (API keys, passwords, DB creds). Use HashiCorp Vault or Go crypto for encryption. Protect endpoints with RBAC. Secure API with JWT, enforce rate limits, use TLS with mutual authentication, and inject secrets at runtime securely. Enforce secure headers, cookie settings, and validate all request payloads.",
  "tags": [
    "CORS & CSRF", "XSS Prevention", "Secure Token Storage", "Secrets Management", "TLS Certs",
    "Brute Force Protection", "Request Validation", "API Abuse Protection", "Hidden Server Headers",
    "Secure Headers", "Content-Type Enforcement", "Rate Limiting", "Token Rotation",
    "Penetration Testing Tools", "GDPR & Cookie Compliance",

    "REST API", "JWT Auth", "Session Auth", "Validation", "Encryption", "Interfaces", "Logging",
    "Packages", "Functions", "Context", "Go Tools", "Reverse Proxy"
  ]
}
,
{
  "id": 144,
  "name": "Admin Panel (Multi-Tenant + Scoped Auth)",
  "challenge": 4,
  "level": 8,
  "completed": false,
  "published": false,
  "description": "Create a multi-tenant admin interface with scoped JWTs. Limit API visibility and actions per role (admin, viewer). Rotate access tokens securely and prevent XSS in all form inputs. Enable CSRF protection for form submissions. Enforce CORS policies per tenant. Add brute-force IP blocking, rate limits, and audit trails for actions. Include a cookie consent manager.",
  "tags": [
    "CORS & CSRF",
    "XSS Prevention",
    "Secure Token Storage",
    "Secrets Management",
    "TLS Certs",
    "Brute Force Protection",
    "Request Validation",
    "API Abuse Protection",
    "Hidden Server Headers",
    "Secure Headers",
    "Content-Type Enforcement",
    "Rate Limiting",
    "Token Rotation",
    "Penetration Testing Tools",
    "GDPR & Cookie Compliance",
    "JWT Auth",
    "RBAC",
    "Session Auth",
    "Pagination",
    "Form Validation",
    "Logging",
    "Reverse Proxy",
    "HTML Templates",
    "Structs",
    "Interfaces",
    "Functions",
    "Context"
  ]
},
{
  "id": 145,
  "name": "Security Middleware Proxy (HMAC Signatures)",
  "challenge": 5,
  "level": 8,
  "completed": false,
  "published": false,
  "description": "Develop a middleware proxy that validates signed HTTP requests (HMAC). Verify each request signature before passing it to upstream services. Add secure headers, limit content types, hide server data, and enforce HTTPS. Rotate keys using secrets manager. Trace all requests, block abusive IPs, and validate payload sizes. Ensure XSS and CSRF protections are active.",
  "tags": [
    "CORS & CSRF", "XSS Prevention", "Secure Token Storage", "Secrets Management", "TLS Certs",
    "Brute Force Protection", "Request Validation", "API Abuse Protection", "Hidden Server Headers",
    "Secure Headers", "Content-Type Enforcement", "Rate Limiting", "Token Rotation",
    "Penetration Testing Tools", "GDPR & Cookie Compliance",

    "Middleware", "Reverse Proxy", "Logging", "Validation", "Structs", "Interfaces",
    "Functions", "Go Tools", "Context"
  ]
}
,
{
  "id": 146,
  "name": "GraphQL Gateway (CSRF + Rate + XSS)",
  "challenge": 6,
  "level": 8,
  "completed": false,
  "published": false,
  "description": "Create a secure GraphQL gateway. Protect mutations against CSRF. Prevent reflected XSS and query abuse with depth/complexity limiting. Apply rate-limiting by user/IP and JWT session. Enforce content-type headers and TLS. All tokens are stored securely (HTTP-only cookies) and rotated periodically. Block bots via user-agent filters and penetration test the full schema.",
  "tags": [
    "CORS & CSRF",
    "XSS Prevention",
    "Secure Token Storage",
    "Secrets Management",
    "TLS Certs",
    "Brute Force Protection",
    "Request Validation",
    "API Abuse Protection",
    "Hidden Server Headers",
    "Secure Headers",
    "Content-Type Enforcement",
    "Rate Limiting",
    "Token Rotation",
    "Penetration Testing Tools",
    "GDPR & Cookie Compliance",
    "GraphQL",
    "JWT Auth",
    "Session Auth",
    "Logging",
    "HTTPS",
    "Structs",
    "Context",
    "Go Tools",
    "Packages"
  ]
},
{
  "id": 147,
  "name": "Public API Proxy (Quota + Abuse Detection)",
  "challenge": 7,
  "level": 8,
  "completed": false,
  "published": false,
  "description": "Create a proxy for a public API with strict quotas and abuse protection. Track IP usage via Redis and block brute-force attempts. Enforce rate limits, hidden headers, secure content types, and custom error masking. Use TLS certs and CSRF tokens for dashboard access. Rotate tokens daily. Provide audit logs and real-time abuse alerts.",
  "tags": [
    "CORS & CSRF",
    "XSS Prevention",
    "Secure Token Storage",
    "Secrets Management",
    "TLS Certs",
    "Brute Force Protection",
    "Request Validation",
    "API Abuse Protection",
    "Hidden Server Headers",
    "Secure Headers",
    "Content-Type Enforcement",
    "Rate Limiting",
    "Token Rotation",
    "Penetration Testing Tools",
    "GDPR & Cookie Compliance",
    "Reverse Proxy",
    "Logging",
    "HTTPS",
    "Session Auth",
    "Packages",
    "Context",
    "Go Tools"
  ]
},
{
  "id": 148,
  "name": "Login Rate-Limit + CAPTCHA Middleware",
  "challenge": 8,
  "level": 8,
  "completed": false,
  "published": false,
  "description": "Design a middleware that protects login endpoints from brute-force attacks. Enforce IP and email-based rate limits. Trigger CAPTCHA challenge after multiple failed attempts. All responses must follow secure headers and correct status codes. Trace attacks and lockout accounts. Test the system using penetration tools and allow CAPTCHA bypass for test users only.",
  "tags": [
    "CORS & CSRF",
    "XSS Prevention",
    "Secure Token Storage",
    "Secrets Management",
    "TLS Certs",
    "Brute Force Protection",
    "Request Validation",
    "API Abuse Protection",
    "Hidden Server Headers",
    "Secure Headers",
    "Content-Type Enforcement",
    "Rate Limiting",
    "Token Rotation",
    "Penetration Testing Tools",
    "GDPR & Cookie Compliance",
    "Middleware",
    "JWT Auth",
    "Session Auth",
    "Validation",
    "Logging",
    "Go Tools",
    "Context"
  ]
},
{
  "id": 149,
  "name": "Gateway Auth Guard (Rotation + Expiry)",
  "challenge": 9,
  "level": 8,
  "completed": false,
  "published": false,
  "description": "Implement a Go-based API Gateway Auth Guard that handles token expiry and rotation. Enforce expiration time rules, verify JWT signatures, and rotate refresh tokens securely. Audit token reuse attempts and respond with strict CORS, headers, and rate caps. Apply OpenTelemetry for tracing and test JWT forgery scenarios using external tools.",
  "tags": [
    "CORS & CSRF",
    "XSS Prevention",
    "Secure Token Storage",
    "Secrets Management",
    "TLS Certs",
    "Brute Force Protection",
    "Request Validation",
    "API Abuse Protection",
    "Hidden Server Headers",
    "Secure Headers",
    "Content-Type Enforcement",
    "Rate Limiting",
    "Token Rotation",
    "Penetration Testing Tools",
    "GDPR & Cookie Compliance",
    "API Gateway",
    "JWT Auth",
    "Middleware",
    "Logging",
    "Context",
    "Packages",
    "Imports",
    "Go Tools"
  ]
},
{
  "id": 150,
  "name": "Go Security Scanner Tool (Audit CLI)",
  "challenge": 10,
  "level": 8,
  "completed": false,
  "published": false,
  "description": "Build a CLI tool that audits a Go web project for security weaknesses. Detect CSRF tokens, header misuse, CORS misconfig, unsafe cookie storage, missing TLS setup, weak JWT handling, token reuse, missing validations, XSS risks, and GDPR violations. Output a full report and remediation checklist. Run test scans on multiple Go repos.",
  "tags": [
    "CORS & CSRF",
    "XSS Prevention",
    "Secure Token Storage",
    "Secrets Management",
    "TLS Certs",
    "Brute Force Protection",
    "Request Validation",
    "API Abuse Protection",
    "Hidden Server Headers",
    "Secure Headers",
    "Content-Type Enforcement",
    "Rate Limiting",
    "Token Rotation",
    "Penetration Testing Tools",
    "GDPR & Cookie Compliance",
    "Go Tools",
    "CLI App",
    "Security",
    "Auditing",
    "Packages",
    "Functions",
    "Structs",
    "Interfaces"
  ]
},
{
  "id": 151,
  "name": "Two-Factor Auth System (2FA + Rotation)",
  "challenge": 11,
  "level": 8,
  "completed": false,
  "published": false,
  "description": "Build a two-factor authentication system using TOTP or SMS. Implement secure delivery and fallback options. Ensure all tokens expire, are securely stored, and are rotated. Apply CSRF protection to setup flows. Add brute force prevention, rate limits, and content-type enforcement. Perform penetration testing and log every attempt securely.",
  "tags": [
    "CORS & CSRF",
    "XSS Prevention",
    "Secure Token Storage",
    "Secrets Management",
    "TLS Certs",
    "Brute Force Protection",
    "Request Validation",
    "API Abuse Protection",
    "Hidden Server Headers",
    "Secure Headers",
    "Content-Type Enforcement",
    "Rate Limiting",
    "Token Rotation",
    "Penetration Testing Tools",
    "GDPR & Cookie Compliance",
    "2FA",
    "JWT Auth",
    "Form Validation",
    "HTTPS",
    "Logging",
    "Structs",
    "Packages",
    "Context"
  ]
},
{
  "id": 152,
  "name": "Secure Webhooks Listener (Signature + Replay Defense)",
  "challenge": 12,
  "level": 8,
  "completed": false,
  "published": false,
  "description": "Create a webhook listener that verifies HMAC or RSA signatures on incoming requests. Enforce replay attack protection with timestamp validation and request ID deduplication. Apply secure headers, strict content-types, and abuse throttling. Run header-based validation and store logs for audit trails. Use penetration testing to validate your defenses.",
  "tags": [
    "CORS & CSRF",
    "XSS Prevention",
    "Secure Token Storage",
    "Secrets Management",
    "TLS Certs",
    "Brute Force Protection",
    "Request Validation",
    "API Abuse Protection",
    "Hidden Server Headers",
    "Secure Headers",
    "Content-Type Enforcement",
    "Rate Limiting",
    "Token Rotation",
    "Penetration Testing Tools",
    "GDPR & Cookie Compliance",
    "Webhooks",
    "JWT Auth",
    "Logging",
    "Validation",
    "HTTPS",
    "Context",
    "Go Tools",
    "Structs"
  ]
},
{
  "id": 153,
  "name": "Encrypted Audit Logs (GDPR + RBAC)",
  "challenge": 13,
  "level": 8,
  "completed": false,
  "published": false,
  "description": "Build a secure audit logging system. Encrypt log entries at rest. Enforce access scopes and RBAC to read logs. Add GDPR support for data removal requests. Use secure cookie/session auth, rate limiting, and full validation. Expose logs via paginated API and CLI. Run penetration tests and ensure headers/content rules.",
  "tags": [
    "CORS & CSRF",
    "XSS Prevention",
    "Secure Token Storage",
    "Secrets Management",
    "TLS Certs",
    "Brute Force Protection",
    "Request Validation",
    "API Abuse Protection",
    "Hidden Server Headers",
    "Secure Headers",
    "Content-Type Enforcement",
    "Rate Limiting",
    "Token Rotation",
    "Penetration Testing Tools",
    "GDPR & Cookie Compliance",
    "Logging",
    "Encryption",
    "RBAC",
    "Pagination",
    "JWT Auth",
    "HTTPS",
    "CLI",
    "Structs",
    "Context",
    "Go Tools"
  ]
},
{
  "id": 154,
  "name": "Token Scanner + Abuse Protection CLI",
  "challenge": 14,
  "level": 8,
  "completed": false,
  "published": false,
  "description": "Write a CLI tool that scans codebases and logs for exposed tokens. Integrate with Secrets Manager to automatically revoke and rotate tokens. Add abuse tracking and alerting system. Use secure headers for notifications. All CLI outputs must be JSON-parsable, secure, and include metadata. Include rate limit logs and privacy compliance.",
  "tags": [
    "CORS & CSRF",
    "XSS Prevention",
    "Secure Token Storage",
    "Secrets Management",
    "TLS Certs",
    "Brute Force Protection",
    "Request Validation",
    "API Abuse Protection",
    "Hidden Server Headers",
    "Secure Headers",
    "Content-Type Enforcement",
    "Rate Limiting",
    "Token Rotation",
    "Penetration Testing Tools",
    "GDPR & Cookie Compliance",
    "CLI",
    "JWT Auth",
    "Validation",
    "Logging",
    "Structs",
    "Context",
    "Go Tools"
  ]
},
{
  "id": 155,
  "name": "Secure Metrics Collector (Token Rotation + Headers)",
  "challenge": 15,
  "level": 8,
  "completed": false,
  "published": false,
  "description": "Build a metrics collector that receives requests from trusted services. Enforce HMAC-authentication per service, rotate secrets regularly, and block invalid tokens. Use strict content-type checks, hidden headers, and CORS controls. Validate request shapes, rate-limit ingestion, and expose metrics via secure gRPC or REST endpoint. Logs must be encrypted and penetration-tested.",
  "tags": [
    "CORS & CSRF",
    "XSS Prevention",
    "Secure Token Storage",
    "Secrets Management",
    "TLS Certs",
    "Brute Force Protection",
    "Request Validation",
    "API Abuse Protection",
    "Hidden Server Headers",
    "Secure Headers",
    "Content-Type Enforcement",
    "Rate Limiting",
    "Token Rotation",
    "Penetration Testing Tools",
    "GDPR & Cookie Compliance",
    "Logging",
    "Metrics",
    "Validation",
    "gRPC",
    "REST API",
    "JWT Auth",
    "Structs",
    "Context",
    "Go Tools"
  ]
},
{
  "id": 156,
  "name": "Dockerized Multi-Service App (Compose + Restart)",
  "challenge": 1,
  "level": 9,
  "completed": false,
  "published": false,
  "description": "Containerize a multi-service Go app using Docker. Use Docker Compose to orchestrate the API, PostgreSQL, and Redis. Configure automatic restart and healthcheck probes. Optimize images with multi-stage builds. Setup `.env` support, mount volume-based logs, and serve gzip-compressed static assets. Track metrics with Prometheus and visualize in Grafana.",
  "tags": [
    "Dockerize Go App",
    "Docker Compose",
    "CI/CD (GitHub Actions / GitLab CI)",
    "Health Checks and Readiness",
    "Env Configuration",
    "Static File Fingerprinting",
    "Asset Compression (gzip, brotli)",
    "Monitoring & Metrics (Prometheus + Grafana)",
    "Container Orchestration",
    "Horizontal Scaling and Load Balancing",
    "Git Versioning",
    "Air / Reflex for Hot Reload",
    "Kubernetes Deployment",
    "REST API",
    "Logging",
    "HTTPS",
    "Go Tools",
    "Structs",
    "Context"
  ]
},
{
  "id": 157,
  "name": "CI/CD Pipeline (Actions + Gzip Builds)",
  "challenge": 2,
  "level": 9,
  "completed": false,
  "published": false,
  "description": "Setup a full CI/CD pipeline using GitHub Actions. Lint, test, and build Go binaries on push. Add static asset fingerprinting and gzip compression. Use tagged Docker images for releases. Deploy on success to a cloud server via SSH or a container registry. Trigger Kubernetes rollout via webhook. Version everything via Git tags.",
  "tags": [
    "Dockerize Go App",
    "CI/CD (GitHub Actions / GitLab CI)",
    "Git Versioning",
    "Static File Fingerprinting",
    "Asset Compression (gzip, brotli)",
    "Kubernetes Deployment",
    "Container Orchestration",
    "Monitoring & Metrics (Prometheus + Grafana)",
    "Health Checks and Readiness",
    "Env Configuration",
    "Docker Compose",
    "Air / Reflex for Hot Reload",
    "Horizontal Scaling and Load Balancing",
    "Go Tools",
    "Logging",
    "Packages",
    "Structs",
    "Functions",
    "Context"
  ]
},
{
  "id": 158,
  "name": "Kubernetes Go API (Scaling + Probes)",
  "challenge": 3,
  "level": 9,
  "completed": false,
  "published": false,
  "description": "Deploy a Go API to Kubernetes using Helm. Define readiness and liveness probes. Enable horizontal pod autoscaling (HPA) and set CPU/memory limits. Configure environment via secrets and config maps. Deploy Prometheus and Grafana to collect metrics. Serve assets with brotli compression. Integrate GitLab CI to auto-rollout with semantic versioning.",
  "tags": [
    "Dockerize Go App",
    "Kubernetes Deployment",
    "Health Checks and Readiness",
    "Horizontal Scaling and Load Balancing",
    "Env Configuration",
    "Monitoring & Metrics (Prometheus + Grafana)",
    "CI/CD (GitHub Actions / GitLab CI)",
    "Container Orchestration",
    "Git Versioning",
    "Static File Fingerprinting",
    "Asset Compression (gzip, brotli)",
    "Docker Compose",
    "Air / Reflex for Hot Reload",
    "REST API",
    "Packages",
    "Imports",
    "Logging",
    "Go Tools",
    "Context",
    "Structs"
  ]
},
{
  "id": 159,
  "name": "Hot Reload Dev Env (Reflex + .env)",
  "challenge": 4,
  "level": 9,
  "completed": false,
  "published": false,
  "description": "Setup a Go project with Reflex for hot reload during local development. Load environment variables from `.env` files and display build info (from Git tags) in the version endpoint. Configure Docker for development (live volume mounts), gzip all frontend assets, and expose Prometheus-compatible metrics. Ready for deployment to a Kubernetes dev cluster.",
  "tags": [
    "Air / Reflex for Hot Reload",
    "Env Configuration",
    "Dockerize Go App",
    "Docker Compose",
    "Monitoring & Metrics (Prometheus + Grafana)",
    "Git Versioning",
    "CI/CD (GitHub Actions / GitLab CI)",
    "Static File Fingerprinting",
    "Asset Compression (gzip, brotli)",
    "Kubernetes Deployment",
    "Container Orchestration",
    "Health Checks and Readiness",
    "Horizontal Scaling and Load Balancing",
    "Go Tools",
    "Structs",
    "Context",
    "Functions",
    "Logging"
  ]
},
{
  "id": 160,
  "name": "Compressed Static Site (CDN + CI Deploy)",
  "challenge": 5,
  "level": 9,
  "completed": false,
  "published": false,
  "description": "Create a static Go-based documentation site. Minify and compress all assets (brotli + gzip), add unique hashes (fingerprinting) and deploy to GitHub Pages via GitHub Actions. Use a CDN (Cloudflare) to serve with TLS. Version each release via Git tags. Monitor availability and TTL via Prometheus exporters.",
  "tags": [
    "CI/CD (GitHub Actions / GitLab CI)",
    "Static File Fingerprinting",
    "Asset Compression (gzip, brotli)",
    "Git Versioning",
    "Monitoring & Metrics (Prometheus + Grafana)",
    "Dockerize Go App",
    "Env Configuration",
    "Container Orchestration",
    "Air / Reflex for Hot Reload",
    "Kubernetes Deployment",
    "Docker Compose",
    "Health Checks and Readiness",
    "Horizontal Scaling and Load Balancing",
    "Go Tools",
    "HTML Templates",
    "HTTPS",
    "Packages",
    "Logging"
  ]
},
{
  "id": 161,
  "name": "Blue/Green Deployment (K8s + GitLab CI)",
  "challenge": 6,
  "level": 9,
  "completed": false,
  "published": false,
  "description": "Implement a blue/green deployment strategy using GitLab CI and Kubernetes. Automatically deploy new versions in parallel, switch traffic using a Service/Ingress, and monitor with readiness probes. Rollback if errors are detected. Track versions via Git tags, compress assets, and fingerprint static content. Expose Prometheus metrics and send alerts via Grafana.",
  "tags": [
    "Dockerize Go App",
    "Docker Compose",
    "CI/CD (GitHub Actions / GitLab CI)",
    "Kubernetes Deployment",
    "Container Orchestration",
    "Health Checks and Readiness",
    "Horizontal Scaling and Load Balancing",
    "Env Configuration",
    "Air / Reflex for Hot Reload",
    "Git Versioning",
    "Static File Fingerprinting",
    "Asset Compression (gzip, brotli)",
    "Monitoring & Metrics (Prometheus + Grafana)",
    "REST API",
    "Logging",
    "HTTPS",
    "Structs",
    "Functions",
    "Go Tools",
    "Context"
  ]
},
{
  "id": 162,
  "name": "Canary Deployment (Metrics + Rollout)",
  "challenge": 7,
  "level": 9,
  "completed": false,
  "published": false,
  "description": "Configure a canary release strategy with gradual rollout. Deploy new versions to 5%, 25%, and 100% of traffic while monitoring metrics with Prometheus. Use Grafana alerts to detect regressions. Automate the rollout via GitHub Actions, compress static files, and use tagged versions. Rollback on error using Helm and Kubernetes health probes.",
  "tags": [
    "Dockerize Go App",
    "Docker Compose",
    "CI/CD (GitHub Actions / GitLab CI)",
    "Kubernetes Deployment",
    "Container Orchestration",
    "Health Checks and Readiness",
    "Horizontal Scaling and Load Balancing",
    "Env Configuration",
    "Git Versioning",
    "Static File Fingerprinting",
    "Asset Compression (gzip, brotli)",
    "Monitoring & Metrics (Prometheus + Grafana)",
    "Air / Reflex for Hot Reload",
    "Go Tools",
    "Logging",
    "HTTPS",
    "Functions",
    "Context",
    "Packages"
  ]
},
{
  "id": 163,
  "name": "DevOps Audit Dashboard (CI + Logs + Traces)",
  "challenge": 8,
  "level": 9,
  "completed": false,
  "published": false,
  "description": "Create an audit dashboard that collects CI build logs, K8s deployment events, health checks, and Prometheus metrics. Integrate Grafana panels for traces, alerts, and uptime. Add gzip compression for API responses and use Git tags for build versioning. Deploy all dashboards via Docker Compose with environment switching support.",
  "tags": [
    "Monitoring & Metrics (Prometheus + Grafana)", "CI/CD (GitHub Actions / GitLab CI)", "Dockerize Go App",
    "Kubernetes Deployment", "Docker Compose", "Container Orchestration", "Health Checks and Readiness",
    "Static File Fingerprinting", "Asset Compression (gzip, brotli)", "Env Configuration",
    "Git Versioning", "Horizontal Scaling and Load Balancing", "Air / Reflex for Hot Reload",

    "Logging", "Functions", "HTTPS", "Structs", "Packages", "Context", "Go Tools"
  ]
}
,
{
  "id": 164,
  "name": "Multi-Stage Docker Builder (Tiny Binaries)",
  "challenge": 9,
  "level": 9,
  "completed": false,
  "published": false,
  "description": "Build a Go app using multi-stage Docker builds. First stage compiles with full toolchain, second stage copies only the binary and required certs. Optimize for size (<20MB). Enable compression (brotli), fingerprint assets, and generate version via Git tags. Use Reflex for dev reload and auto-deploy to Kubernetes via GitHub Actions.",
  "tags": [
    "Dockerize Go App",
    "Docker Compose",
    "CI/CD (GitHub Actions / GitLab CI)",
    "Kubernetes Deployment",
    "Container Orchestration",
    "Static File Fingerprinting",
    "Asset Compression (gzip, brotli)",
    "Env Configuration",
    "Health Checks and Readiness",
    "Git Versioning",
    "Air / Reflex for Hot Reload",
    "Monitoring & Metrics (Prometheus + Grafana)",
    "Horizontal Scaling and Load Balancing",
    "Go Tools",
    "Packages",
    "Context",
    "Logging",
    "Functions",
    "HTTPS"
  ]
},
{
  "id": 165,
  "name": "Zero-Downtime Deployment (Rolling + Checks)",
  "challenge": 10,
  "level": 9,
  "completed": false,
  "published": false,
  "description": "Deploy an app with zero downtime using Kubernetes rolling updates. Configure liveness and readiness probes, use Kubernetes strategies to ensure availability. Automate deploys via CI, monitor health via Prometheus, and show current Git version in `/version` endpoint. Serve assets with gzip compression and track metrics in Grafana.",
  "tags": [
    "Kubernetes Deployment",
    "Health Checks and Readiness",
    "Dockerize Go App",
    "Docker Compose",
    "CI/CD (GitHub Actions / GitLab CI)",
    "Container Orchestration",
    "Env Configuration",
    "Git Versioning",
    "Static File Fingerprinting",
    "Asset Compression (gzip, brotli)",
    "Monitoring & Metrics (Prometheus + Grafana)",
    "Horizontal Scaling and Load Balancing",
    "Air / Reflex for Hot Reload",
    "REST API",
    "Logging",
    "Go Tools",
    "Packages",
    "Context",
    "Structs",
    "Functions"
  ]
},
{
  "id": 166,
  "name": "CDN Delivery (Fingerprinting + Brotli)",
  "challenge": 11,
  "level": 9,
  "completed": false,
  "published": false,
  "description": "Serve a static Go app globally via CDN (e.g., Cloudflare). Apply fingerprinting to all CSS/JS/images. Generate both gzip and brotli versions. Automate deploys via GitHub Actions. Use Git tags for versioning and expose version via HTTP header. Set long-term cache headers and monitor CDN availability via Prometheus exporters.",
  "tags": [
    "Static File Fingerprinting",
    "Asset Compression (gzip, brotli)",
    "CI/CD (GitHub Actions / GitLab CI)",
    "Git Versioning",
    "Monitoring & Metrics (Prometheus + Grafana)",
    "Dockerize Go App",
    "Kubernetes Deployment",
    "Env Configuration",
    "Health Checks and Readiness",
    "Docker Compose",
    "Container Orchestration",
    "Horizontal Scaling and Load Balancing",
    "Air / Reflex for Hot Reload",
    "HTTPS",
    "HTML Templates",
    "Go Tools",
    "Logging",
    "Packages",
    "Context"
  ]
},
{
  "id": 167,
  "name": "Helm Chart (Go App K8s Ready)",
  "challenge": 12,
  "level": 9,
  "completed": false,
  "published": false,
  "description": "Write a reusable Helm chart for your Go web app. Include templated envs, probes, resource limits, secrets, ingress, HPA, and config maps. Support CI deployments via GitHub Actions and Git tags. Serve fingerprinted, compressed assets. Validate with Helm lint and integrate Prometheus metrics auto-scrape annotations.",
  "tags": [
    "Kubernetes Deployment",
    "Dockerize Go App",
    "CI/CD (GitHub Actions / GitLab CI)",
    "Env Configuration",
    "Health Checks and Readiness",
    "Horizontal Scaling and Load Balancing",
    "Container Orchestration",
    "Static File Fingerprinting",
    "Asset Compression (gzip, brotli)",
    "Monitoring & Metrics (Prometheus + Grafana)",
    "Git Versioning",
    "Docker Compose",
    "Air / Reflex for Hot Reload",
    "Go Tools",
    "Structs",
    "Context",
    "HTTPS",
    "Functions",
    "Packages"
  ]
},
{
  "id": 168,
  "name": "Release Dashboard (Git Tags + Version UI)",
  "challenge": 13,
  "level": 9,
  "completed": false,
  "published": false,
  "description": "Create a dashboard that reads Git tags and shows release changelogs. Integrate with GitHub/GitLab API. Parse semantic versions and compare them. Deploy with Docker and expose over HTTPS with asset compression. Monitor version adoption via Prometheus counters. CI updates the dashboard automatically on each release.",
  "tags": [
    "Git Versioning",
    "CI/CD (GitHub Actions / GitLab CI)",
    "Dockerize Go App",
    "Docker Compose",
    "Kubernetes Deployment",
    "Env Configuration",
    "Monitoring & Metrics (Prometheus + Grafana)",
    "Static File Fingerprinting",
    "Asset Compression (gzip, brotli)",
    "Air / Reflex for Hot Reload",
    "Container Orchestration",
    "Health Checks and Readiness",
    "Horizontal Scaling and Load Balancing",
    "Go Tools",
    "HTML Templates",
    "HTTPS",
    "Functions",
    "Logging",
    "Context"
  ]
},
{
  "id": 169,
  "name": "Staging Flow (Dev/Prod Envs + Reload)",
  "challenge": 14,
  "level": 9,
  "completed": false,
  "published": false,
  "description": "Deploy staging and production versions of a Go API using Docker Compose + Reflex for dev reload. Use context-aware `.env` and config split. Gzip static assets. Publish via CI and monitor both versions separately. Tag each build, expose version in header, and allow rollback by switching image tag.",
  "tags": [
    "Dockerize Go App",
    "Docker Compose",
    "Air / Reflex for Hot Reload",
    "Env Configuration",
    "CI/CD (GitHub Actions / GitLab CI)",
    "Git Versioning",
    "Monitoring & Metrics (Prometheus + Grafana)",
    "Kubernetes Deployment",
    "Health Checks and Readiness",
    "Horizontal Scaling and Load Balancing",
    "Container Orchestration",
    "Static File Fingerprinting",
    "Asset Compression (gzip, brotli)",
    "REST API",
    "HTTPS",
    "Structs",
    "Packages",
    "Functions",
    "Logging",
    "Context"
  ]
},
{
  "id": 170,
  "name": "Custom Prometheus Exporter (App Observability)",
  "challenge": 15,
  "level": 9,
  "completed": false,
  "published": false,
  "description": "Build a Prometheus exporter in Go that exposes custom metrics for your app: memory usage, number of users, tasks processed, DB status. Add gzip compression to responses. Serve versioned /metrics endpoint. Deploy via Docker/Kubernetes, monitor with Grafana, and auto-release via CI using Git tags. Watch load with HPA metrics.",
  "tags": [
    "Monitoring & Metrics (Prometheus + Grafana)",
    "Dockerize Go App",
    "CI/CD (GitHub Actions / GitLab CI)",
    "Kubernetes Deployment",
    "Container Orchestration",
    "Git Versioning",
    "Health Checks and Readiness",
    "Static File Fingerprinting",
    "Asset Compression (gzip, brotli)",
    "Env Configuration",
    "Air / Reflex for Hot Reload",
    "Docker Compose",
    "Horizontal Scaling and Load Balancing",
    "Go Tools",
    "Logging",
    "HTTPS",
    "Packages",
    "Context",
    "Functions"
  ]
},
{
  "id": 171,
  "name": "In-Memory Search Engine (Ranking + Index)",
  "challenge": 1,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Build a text search engine using inverted index, frequency maps, and custom scoring. Implement ranking with TF-IDF or cosine similarity. Use hash tables for indexing, recursion for scoring tree-walks, and profile memory usage of index growth. Add complexity analysis and optimize slice allocations. Include Leetcode-style performance tracking.",
  "tags": [
    "Go Implementation of Classic Algorithms",
    "Hash Tables",
    "Sorting",
    "Searching",
    "Recursion",
    "Memory Profiling",
    "Time & Space Complexity",
    "Dynamic Programming",
    "Leetcode / HackerRank in Go",
    "Stack",
    "Queue"
  ]
},
{
  "id": 172,
  "name": "LRU Cache (Linked List + Map)",
  "challenge": 2,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Design an LRU cache using a doubly linked list + map. Support Get and Put in O(1). Profile performance with Go benchmarks and memory profiling. Add tests with 1M ops to test GC. Expose /debug endpoint for stats and show real-time eviction logs. Document time/space complexity with examples.",
  "tags": [
    "LinkedList",
    "Hash Tables",
    "Go Implementation of Classic Algorithms",
    "Memory Profiling",
    "Time & Space Complexity",
    "Stack",
    "Queue",
    "Leetcode / HackerRank in Go",
    "Dynamic Programming",
    "Recursion"
  ]
},
{
  "id": 173,
  "name": "Graph Traversal + Cycle Detection",
  "challenge": 3,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Build a tool that loads a directed graph from JSON and allows traversal via BFS and DFS. Detect cycles, compute topological sort, and visualize levels. Implement adjacency list and adjacency matrix models. Use heap for shortest path extensions. Profile stack usage on DFS recursion. Document edge case complexity.",
  "tags": [
    "Trees & Graphs",
    "BFS",
    "DFS",
    "Go Implementation of Classic Algorithms",
    "Recursion",
    "Stack",
    "Queue",
    "Time & Space Complexity",
    "Memory Profiling",
    "Leetcode / HackerRank in Go"
  ]
},
{
  "id": 174,
  "name": "Project Scheduling Optimizer (DP + Memoization)",
  "challenge": 4,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Implement a project scheduler that finds the optimal set of tasks to execute without conflicts for maximum profit. Use dynamic programming + memoization. Track complexity curves for increasing input size. Benchmark different DP approaches (top-down vs bottom-up). Visualize memory via pprof. Document best/worst cases clearly.",
  "tags": [
    "Dynamic Programming",
    "Recursion",
    "Memory Profiling",
    "Time & Space Complexity",
    "Go Implementation of Classic Algorithms",
    "Stack",
    "Leetcode / HackerRank in Go",
    "Hash Tables",
    "Sorting",
    "Queue"
  ]
},
{
  "id": 175,
  "name": "Job Queue with Custom Heap",
  "challenge": 5,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Design a real-time job scheduler using a custom binary heap. Support dynamic priority changes and insertion/deletion in log(n). Implement min/max variants and profile insertion vs heapify. Compare Go's container/heap vs custom version. Track CPU/mem performance under load. Add competitive complexity report.",
  "tags": [
    "Heaps",
    "Go Implementation of Classic Algorithms",
    "Time & Space Complexity",
    "Memory Profiling",
    "Sorting",
    "Queue",
    "Stack",
    "Recursion",
    "Leetcode / HackerRank in Go",
    "Hash Tables"
  ]
},
{
  "id": 176,
  "name": "Autocomplete Engine (Trie + Prefix Score)",
  "challenge": 6,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Build an autocomplete engine using a Trie to support real-time prefix lookup. Implement scoring by frequency and recency using a max-heap. Optimize for low memory usage. Benchmark lookups for various prefix depths. Profile with pprof and show exact space complexity of Trie vs HashMap-based approach.",
  "tags": [
    "Go Implementation of Classic Algorithms",
    "Heaps",
    "Hash Tables",
    "Recursion",
    "Memory Profiling",
    "Time & Space Complexity",
    "Dynamic Programming",
    "Leetcode / HackerRank in Go",
    "Searching",
    "Stack"
  ]
},{
  "id": 176,
  "name": "Autocomplete Engine (Trie + Prefix Score)",
  "challenge": 6,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Build an autocomplete engine using a Trie to support real-time prefix lookup. Implement scoring by frequency and recency using a max-heap. Optimize for low memory usage. Benchmark lookups for various prefix depths. Profile with pprof and show exact space complexity of Trie vs HashMap-based approach.",
  "tags": [
    "Go Implementation of Classic Algorithms",
    "Heaps",
    "Hash Tables",
    "Recursion",
    "Memory Profiling",
    "Time & Space Complexity",
    "Dynamic Programming",
    "Leetcode / HackerRank in Go",
    "Searching",
    "Stack"
  ]
}
,
{
  "id": 178,
  "name": "Syntax Parser (Recursive Descent)",
  "challenge": 8,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Design a recursive descent parser for a small language or config DSL. Build an AST with tree nodes, validate token order, and throw detailed error messages. Use stack recursion, optimize memory, and profile tree creation. Track time complexity for deeply nested expressions. Add unit tests covering edge case grammars.",
  "tags": [
    "Recursion",
    "Stack",
    "Trees & Graphs",
    "Go Implementation of Classic Algorithms",
    "Time & Space Complexity",
    "Memory Profiling",
    "Leetcode / HackerRank in Go",
    "Hash Tables",
    "Dynamic Programming",
    "Searching"
  ]
},
{
  "id": 179,
  "name": "Leaderboard System (Skip List + Ranking)",
  "challenge": 9,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Implement a leaderboard that supports top-N, nearest ranks, and percentile lookup using skip list. Compare against slice+sort performance. Optimize pointer layout to reduce GC pressure. Track CPU and memory profile over millions of updates. Visualize time-space tradeoff between list height and speed.",
  "tags": [
    "Go Implementation of Classic Algorithms",
    "Sorting",
    "Memory Profiling",
    "Time & Space Complexity",
    "Hash Tables",
    "Queue",
    "Stack",
    "Dynamic Programming",
    "Leetcode / HackerRank in Go",
    "Recursion"
  ]
},
{
  "id": 180,
  "name": "Text Analyzer (Frequency + Heap Profiling)",
  "challenge": 10,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Parse large text files and extract word frequency, sentence length, and structure. Store word counts using hash map and maintain top-K frequent words using heap. Profile with Go's memory profiler and benchmark throughput with large inputs. Apply GC tuning and visualize performance with flamegraphs.",
  "tags": [
    "Hash Tables",
    "Heaps",
    "Go Implementation of Classic Algorithms",
    "Memory Profiling",
    "Time & Space Complexity",
    "Sorting",
    "Leetcode / HackerRank in Go",
    "Stack",
    "Queue",
    "Recursion"
  ]
},
{
  "id": 181,
  "name": "Streaming Median Calculator (Dual Heaps)",
  "challenge": 11,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Build a streaming median calculator using a min-heap and max-heap. Each insertion updates the median instantly. Benchmark time complexity and compare against slice-based sort. Track memory pressure with Go's heap profiler. Add APIs to expose percentiles and implement edge-case handling (duplicates, floats, limits).",
  "tags": [
    "Heaps",
    "Go Implementation of Classic Algorithms",
    "Memory Profiling",
    "Time & Space Complexity",
    "Sorting",
    "Stack",
    "Queue",
    "Recursion",
    "Leetcode / HackerRank in Go",
    "Hash Tables"
  ]
},
{
  "id": 182,
  "name": "Aho-Corasick Matcher (Multiple Patterns)",
  "challenge": 12,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Implement the Aho-Corasick algorithm for efficient multiple string pattern matching. Build a Trie with failure links and profile both time and memory usage. Compare with naive substring scanning. Visualize memory layout of nodes. Track complexity on increasing keyword sets and apply to large document scans.",
  "tags": [
    "Go Implementation of Classic Algorithms",
    "Trie",
    "Recursion",
    "Hash Tables",
    "Time & Space Complexity",
    "Memory Profiling",
    "Leetcode / HackerRank in Go",
    "Searching",
    "Queue",
    "Stack"
  ]
},
{
  "id": 183,
  "name": "Interval Merger (Dynamic Scheduling)",
  "challenge": 13,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Create a dynamic interval merging system for managing reservations or time blocks. Use a balanced tree or slice+sort hybrid approach. Handle add, remove, and merge operations. Benchmark merging overhead and profile GC behavior. Track complexity of insertion and detection across overlapping intervals.",
  "tags": [
    "Sorting",
    "Go Implementation of Classic Algorithms",
    "Time & Space Complexity",
    "Memory Profiling",
    "Dynamic Programming",
    "Leetcode / HackerRank in Go",
    "Stack",
    "Queue",
    "Hash Tables",
    "Recursion"
  ]
},
{
  "id": 184,
  "name": "Minimax Solver (Alpha-Beta + Memo)",
  "challenge": 14,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Write a turn-based game AI using Minimax with alpha-beta pruning and memoization. Optimize node exploration with transposition tables (hash maps). Track recursive depth and pruning ratio. Profile memory usage on game trees with 10k+ nodes. Compare full vs pruned tree complexity and log decision paths.",
  "tags": [
    "Recursion",
    "Go Implementation of Classic Algorithms",
    "Hash Tables",
    "Dynamic Programming",
    "Time & Space Complexity",
    "Memory Profiling",
    "Stack",
    "Leetcode / HackerRank in Go",
    "Trees & Graphs",
    "Searching"
  ]
},
{
  "id": 185,
  "name": "Suffix & LCP Arrays (Search Engine Index)",
  "challenge": 15,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Build a suffix array and longest common prefix (LCP) array generator. Use radix sort or binary doubling. Apply to search queries or DNA sequence compression. Benchmark space usage vs performance. Visualize prefix tree compression and memory layout. Compare naive vs optimized implementations and profile sorting stages.",
  "tags": [
    "Go Implementation of Classic Algorithms",
    "Sorting",
    "Memory Profiling",
    "Time & Space Complexity",
    "Recursion",
    "Leetcode / HackerRank in Go",
    "Hash Tables",
    "Searching",
    "Stack",
    "Dynamic Programming"
  ]
},
{
  "id": 186,
  "name": "Union-Find System (Dynamic Connectivity)",
  "challenge": 16,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Implement Union-Find (Disjoint Set Union) with path compression and union by rank. Support dynamic connectivity queries between nodes. Benchmark against graph DFS for online queries. Profile memory layout, track space savings using parent optimization, and expose complexity graphs.",
  "tags": [
    "Go Implementation of Classic Algorithms",
    "Trees & Graphs",
    "Recursion",
    "Hash Tables",
    "Time & Space Complexity",
    "Memory Profiling",
    "Leetcode / HackerRank in Go",
    "Stack",
    "Queue",
    "Dynamic Programming"
  ]
},
{
  "id": 187,
  "name": "Sliding Window Max/Min (Monotonic Stack)",
  "challenge": 17,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Implement an efficient sliding window max/min system using a monotonic stack or deque. Benchmark against naive solutions. Track memory allocations and execution time with large datasets. Apply in performance-critical systems like stock trend analysis. Expose rolling metrics via API endpoints.",
  "tags": [
    "Stack",
    "Queue",
    "Sorting",
    "Go Implementation of Classic Algorithms",
    "Memory Profiling",
    "Time & Space Complexity",
    "Dynamic Programming",
    "Recursion",
    "Leetcode / HackerRank in Go",
    "Hash Tables"
  ]
},
{
  "id": 188,
  "name": "Fast Modular Exponentiation (Pow Mod System)",
  "challenge": 18,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Create a utility to compute large exponents modulo a prime efficiently using binary exponentiation. Profile stack depth and time complexity for increasing exponent sizes. Use it to build a lightweight RSA encryption demo. Benchmark vs standard lib math functions and visualize performance.",
  "tags": [
    "Recursion",
    "Dynamic Programming",
    "Go Implementation of Classic Algorithms",
    "Memory Profiling",
    "Time & Space Complexity",
    "Hash Tables",
    "Leetcode / HackerRank in Go",
    "Stack",
    "Queue",
    "Sorting"
  ]
},
{
  "id": 189,
  "name": "Bitmask DP Solver (Set Cover + TSP)",
  "challenge": 19,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Use bitmask dynamic programming to solve problems like Set Cover and Traveling Salesman. Implement subset memoization and XOR optimizations. Benchmark for up to 2^20 sets. Track space explosion and prune states where possible. Profile CPU/heap and document cache hit ratios.",
  "tags": [
    "Dynamic Programming",
    "Recursion",
    "Go Implementation of Classic Algorithms",
    "Memory Profiling",
    "Time & Space Complexity",
    "Hash Tables",
    "Stack",
    "Queue",
    "Leetcode / HackerRank in Go",
    "Sorting"
  ]
},
{
  "id": 190,
  "name": "Competitive Go Toolkit (Bench + Profile)",
  "challenge": 20,
  "level": 10,
  "completed": false,
  "published": false,
  "description": "Build a CLI toolkit to benchmark and profile algorithms (sorts, heaps, DP, trees). Include options for time/space graphs, flamegraphs, and GC logs. Input via JSON or file stream. Output results in tables or charts. Modularize each algo as a testable unit. Ideal for competitive Go or interview prep.",
  "tags": [
    "Go Implementation of Classic Algorithms",
    "Memory Profiling",
    "Time & Space Complexity",
    "Leetcode / HackerRank in Go",
    "Dynamic Programming",
    "Sorting",
    "Recursion",
    "Stack",
    "Queue",
    "Hash Tables"
  ]
},
{
  "id": 191,
  "name": "Minimal Go Blockchain (Merkle + Wallets)",
  "challenge": 1,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Build a minimal blockchain implementation in Go. Each block contains a Merkle root of its transactions. Generate deterministic HD wallets using BIP-39 + BIP-44 with mnemonic phrases. Implement Base58 and Bech32 address encoders. Track and sign transactions using secp256k1 keys. Each node communicates over a simple P2P layer. No database, in-memory only.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 192,
  "name": "Blockchain Node Mesh (Gossip Sync)",
  "challenge": 2,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Design a decentralized node mesh using Go's net package and a gossip-style protocol. Nodes exchange block headers and verify transactions via Merkle roots. Each node hosts its wallet and can sign and broadcast new transactions. Use ed25519 for signing, and log consensus events. Ensure each peer verifies hashes before accepting blocks.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 193,
  "name": "Transaction Pool + PoW Miner",
  "challenge": 3,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Implement a basic transaction pool with a miner that validates and includes transactions in new blocks. Use proof-of-work as consensus, verifying difficulty before broadcasting. Sign transactions using HD wallets. Display pending, confirmed, and orphaned txs. Profile Merkle tree creation time for large tx sets.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 194,
  "name": "Token Engine (ERC20 Clone)",
  "challenge": 4,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Add custom token logic to your blockchain. Support balances, allowances, transfers, and total supply similar to ERC20. Track token states in memory. Sign token transactions using secp256k1. Include token metadata in transaction payloads. Add JSON-RPC endpoint to query balances. Use base58 for address encoding.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 195,
  "name": "Smart Contract Client (ABI Calls)",
  "challenge": 5,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Write a Go module that reads Ethereum contract ABIs and allows interaction with deployed smart contracts. Encode and decode function calls manually. Use Infura or custom RPC for submitting transactions. Wallets sign txs offline using BIP-32-derived keys. Verify calldata hashes with keccak256. Support ERC20 and custom contracts.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 196,
  "name": "Cold Wallet Generator + Recovery",
  "challenge": 6,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Build an offline cold wallet generator using BIP-39 mnemonics and BIP-44 derivation paths. Support multiple coins (Bitcoin, Ethereum). Display QR code for public address only. Allow restoration from seed phrases and check address validity via checksum. Integrate address encoding in Base58 and Bech32. Use secp256k1 and ed25519 as selectable options.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 197,
  "name": "Ethereum Light Client (Header Verifier)",
  "challenge": 7,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Build a simplified Ethereum light client that syncs only block headers. Validate the Merkle roots and proof-of-work or checkpoint signatures. Extract logs from logsBloom filter. Implement compact proof structures. Connect to remote node for real-time updates. Sign optional relay txs via HD wallet.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 198,
  "name": "Decentralized Chat (Wallet Identity)",
  "challenge": 8,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Build a P2P chat app where identities are based on wallet addresses. Each message is signed and verified with secp256k1. Use gossip protocol for message sync. Messages are hashed and can be included in optional block structure. Encode identities in Bech32. Show blockchain-derived profiles with ENS-like nicknames.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 199,
  "name": "On-Chain Voting System (Batch Tx)",
  "challenge": 9,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Develop a blockchain-based voting system. Each vote is signed and batched into a block. Use Merkle trees to prove vote inclusion. Wallets sign the vote with BIP-32 derived keys. Broadcast via P2P and validate consensus via majority signature or PoS. Support real-time tally and replayable vote audit log.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 200,
  "name": "Blockchain Explorer (Go-based)",
  "challenge": 10,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Create a blockchain explorer in Go that parses and displays blocks, transactions, and wallet balances from a local node. Show Merkle proofs for transaction verification. Decode addresses in Base58/Bech32. Show token metadata for ERC20-style contracts. Allow searching by address, txid, or block height. Use native Go HTTP server and templates.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 201,
  "name": "Multi-Chain Wallet (Balance Tracker)",
  "challenge": 11,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Build a Go tool that supports multiple blockchains (BTC, ETH, BNB) and tracks balances of native tokens and ERC20/BEP20. Derive wallets via BIP-44 paths, fetch data from public APIs or nodes, and display addresses in both Base58 and Bech32. Securely manage seeds and display QR codes for address export.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 202,
  "name": "ZK Verifier (Snark Interface)",
  "challenge": 12,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Build a zk-SNARK proof verifier using Go and native crypto primitives. Parse proof data, check validity, and connect to zk circuits via foreign function interface or external binary. Validate inputs off-chain and simulate on-chain verification cost. Track performance using profiling tools.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 203,
  "name": "DEX Trading Bot (RPC + Signing)",
  "challenge": 13,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Create a Go bot that connects to a DEX (Uniswap, PancakeSwap) via JSON-RPC. Fetch token pairs, calculate prices, and submit signed transactions. Build wallets from BIP-39 seeds and sign trades using ECDSA. Implement retry and gas price adaptation. Show price chart and transaction logs.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 204,
  "name": "Hardware Wallet Bridge (Ledger, Trezor)",
  "challenge": 14,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Create a Go client that communicates with hardware wallets (via USB, HID, or bridge) to fetch public keys and sign transactions. Interface with Ledger or Trezor APIs. Use standard address encoding and display transaction previews. Ensure secure memory handling and integrate fallback mnemonic restore.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 205,
  "name": "Oracle Consumer (Chainlink/BNB Oracle)",
  "challenge": 15,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Consume on-chain oracles (Chainlink, Band, BNB) using Go and smart contract ABI interaction. Validate oracle responses, detect stale data, and compute TWAPs. Support token price fetching and convert to fiat. Sign txs using local wallet. Profile gas usage and support validator rotation hooks.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 206,
  "name": "MultiSig Wallet CLI (Time-Lock + Approval)",
  "challenge": 16,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Build a CLI and contract system that handles multisig wallets with time-locks. Users must approve transactions via offline signatures. Once quorum is reached and lock expires, the transaction is executed. CLI signs and broadcasts txs using local wallets. Show transaction state in history log.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 207,
  "name": "Smart Contract Test Framework",
  "challenge": 17,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Create a Go testing framework that can deploy, test, and simulate smart contract interaction using JSON ABI. Support forked mainnet tests via Ganache/Hardhat. Generate test vectors for transactions. Validate event emissions, reverts, and state changes.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 208,
  "name": "PoS Validator Simulator",
  "challenge": 18,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Simulate a proof-of-stake validator set with staking, rotation, and slashing. Accept stakes via signed txs. Rotate validators by epoch and randomly slash misbehaving ones. Validate messages via Merkle roots. Use deterministic HD wallets for validator keys. Expose metrics for uptime and slashes.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 209,
  "name": "DEX Aggregator + Routing Optimizer",
  "challenge": 19,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Create a Go client that fetches swap routes from multiple DEXes (1inch, Paraswap) and selects the best path. Sign and submit txs from wallet, support multiple tokens (ERC20/BEP20). Benchmark gas usage and add failover retry. Monitor slippage, tx status, and route history.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
},
{
  "id": 210,
  "name": "Self-Custodial Wallet API (Backend)",
  "challenge": 20,
  "level": 11,
  "completed": false,
  "published": false,
  "description": "Develop a backend API for a self-custodial wallet. Users generate wallets locally and only send signed txs. Store metadata like labels, balance history, token icons. Apply rate limits, sign txs offline, and simulate gas usage before broadcast. Fully stateless wallet core in Go.",
  "tags": [
    "Blockchain Data Structures",
    "Merkle Trees & Hashing",
    "Wallet Generation (BIP-32/39/44)",
    "Address Encoding (Base58, Bech32)",
    "Transaction Creation & Signing",
    "Custom Token Standards (ERC20, BEP20, etc.)",
    "Smart Contract Interaction",
    "Blockchain Nodes & P2P Protocols",
    "Consensus Algorithms (PoW, PoS, etc.)",
    "Crypto Libraries (secp256k1, ed25519)"
  ]
}

]